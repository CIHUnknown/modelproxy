/*!
 * hsf - hsf_protocol.cc
 * Copyright(c) 2012 Taobao.com
 * Author: busi.hyy <busi.hyy@taobao.com>
 */

#include "defines.h"
#include <v8.h>
#include <typeinfo>
#include <string>
#include <map>
#include <vector>
#include <sstream>
// #include <iostream>
// 
#include "transform.h"
#include "hsf_define.h"
#include "objects.h"
#include "hessian_input.h"
#include "hessian_output.h"
#include "hessian_protoc.h"
#include "hsf_protoc.h"
#include "cs_encode.h"
// #include "json_text.h"

using namespace v8;
using namespace hsf;
using namespace std;
using namespace node;

NAN_METHOD(genReqBody);
//hsf consumer encode && decode
NAN_METHOD(requestEncode);
NAN_METHOD(responseDecode);

//hsf heartbeat encode
NAN_METHOD(heartbeatEncode);

//hsf server method
/**
 * hsf serverice handle
 */
// hsf_provider_service *service;
NAN_METHOD(requestDecode);
NAN_METHOD(responseEncode);

NAN_METHOD(cs_regist_encode);
NAN_METHOD(cs_publish_encode);
NAN_METHOD(cs_do_publish_encode);

// Handle<Value> hsfInit;
// Handle<Value> hsfRegistService;
// Handle<Value> hsfPublish;
// Handle<Value> hsfDestroy;

/**
 * generat request body for config server
 */
NAN_METHOD(genReqBody) {
  NanScope();
  if (args.Length()!=2 && !args[0]->IsString() && !args[1]->IsString()) {
    THROW_BAD_ARGS;
  }

  string data;
  hessian_output hout(&data);
  
  Map command("com.taobao.config.server.common.dataobject.Command");
  command.put("id", (hsf::Object*) NULL);
  command.put("name", "getGroupData");

  List params("[object");
  params.push_back(*v8::String::AsciiValue(args[0]));
  params.push_back(*v8::String::AsciiValue(args[1]));
  command.put("params", &params);

  hout.write_object(&command);
  NanReturnValue(NEW_NODE_BUFFER(data));
}

/**
 * encode request for hsf server
 */
NAN_METHOD(requestEncode ){
  NanScope();

  string method_name(*v8::String::AsciiValue(args[1]));
  string service_signature(*v8::String::AsciiValue(args[0]));

  hsf_request_object hsf_req;
  hsf_req.packet_id = (uint64_t)args[2]->IntegerValue();
  hsf_req.protocol = HESSIAN;
  hsf_req.service_signature = &service_signature;
  hsf_req.method_name = &method_name;
  List hsfArgs;
  if(args.Length()>=4) {
    Array* arr = Array::Cast(*(args[3]->ToObject()));
    unsigned len = arr->Length();
    for (unsigned i=0; i!=len; ++i) {
      std::vector<Handle<Value> > vecVal;
      string errmsg = "";
      hsf::Object *arg = v8ToHsf(arr->Get(i), vecVal, errmsg, true);
      hsfArgs.push_back(arg);
      if (errmsg != "") {
        unsigned hsfLen = hsfArgs.size();
        for (unsigned j = 0; j != hsfLen; ++j) {
          if (hsfArgs[j]) {
            delete hsfArgs[j];
          }
        }
        THROW_V8_EXCEPTION(errmsg.c_str());
      }
    }
  }
  hsf_req.method_args = &hsfArgs;
   // printf("%s\n", hsfArgs.debug_text().c_str());
  string output;
  hsf_request_encode(hsf_req, output);
  Handle<Value> res = NEW_NODE_BUFFER(output);
  unsigned hsfLen = hsfArgs.size();
  for (unsigned j = 0; j != hsfLen; ++j) {
    if (hsfArgs[j]) {
      delete hsfArgs[j];
    }
  }  
  NanReturnValue(res);
}

NAN_METHOD(heartbeatEncode ){
  NanScope();
  uint64_t packetId = (uint64_t)args[0]->IntegerValue();
  string output;
  hsf_request_heartbeat_encode(packetId, output);
  Handle<Value> res = NEW_NODE_BUFFER(output);
  NanReturnValue(res);
}

NAN_METHOD(responseDecode ){
  NanScope();
  Local<Value> arg = args[0];
  if(!Buffer::HasInstance(arg)) {
    THROW_V8_EXCEPTION("Decode Response Error: Input must be buffer type!");
  }
  size_t size = Buffer::Length(arg->ToObject());
  char *buf = Buffer::Data(arg->ToObject());
  hsf_response_object output;
  const char * t = hsf_response_decode(buf, size, output);
  if (t == NULL) {
    THROW_V8_EXCEPTION("Decode Response Error: decode buffer error!");
  }
  Local<v8::Object> res = v8::Object::New();
  if (output.type == HEARTBEAT) {
    res->Set(v8::String::NewSymbol("packetType"), v8::String::New("HEARTBEAT"));
  } else {
    res->Set(v8::String::NewSymbol("packetType"), v8::String::New("HSF"));
    res->Set(v8::String::NewSymbol("packetId"), v8::Number::New(output.packet_id));
    res->Set(v8::String::NewSymbol("isError"), v8::Boolean::New(output.error_msg != NULL));
    if (output.error_msg != NULL) {
      res->Set(v8::String::NewSymbol("errorMsg"), v8::String::New(output.error_msg->c_str()));
    }
    string errmsg = "";
    std::vector<hsf::Object *> vecHsfVal;
    std::vector<Handle<Value> > vecV8Val;
    //fprintf(stdout, "app_obj:\n%s\n", output.method_ret->debug_text().c_str());
    res->Set(v8::String::NewSymbol("appResponse"), hsfToV8(output.method_ret, vecHsfVal, vecV8Val, errmsg));
    if (output.method_ret) delete output.method_ret;
    if (output.error_msg) delete output.error_msg;
    if (errmsg != "") {
      THROW_V8_EXCEPTION(errmsg.c_str());
    }
  }
  NanReturnValue(res);
}



/**
 * analysis hsf I/O buffer
 * get an string of json
 */
NAN_METHOD(requestDecode ){
  NanScope();
  Local<Value> arg = args[0];
  if(!Buffer::HasInstance(arg)) {
    THROW_V8_EXCEPTION("Decode Request Error: Input must be buffer type!");
  }
  size_t size = Buffer::Length(arg->ToObject());
  char *buf = Buffer::Data(arg->ToObject());
  hsf_request_object reqObj;
  const char *res = hsf_request_decode(buf, size, reqObj);
  if (res == NULL) {
    THROW_V8_EXCEPTION("Decode Request Error: decode buffer error!");
  }
  Handle<v8::Object> result = v8::Object::New();
  result->Set(v8::String::NewSymbol("packetId"), v8::Number::New(reqObj.packet_id));
  
  if (reqObj.type == HEARTBEAT) {
    result->Set(v8::String::NewSymbol("packetType"), v8::String::New("HEARTBEAT"));
  } else {
    List *realargs = reqObj.method_args;
    result->Set(v8::String::NewSymbol("packetType"), v8::String::New("HSF"));
    result->Set(v8::String::NewSymbol("methodName"), v8::String::New(reqObj.method_name->c_str()));
    std::vector<hsf::Object *> vecHsfVal;
    std::vector<Handle<Value> > vecV8Val;
    string errmsg = "";
    result->Set(v8::String::NewSymbol("args"), hsfToV8(realargs, vecHsfVal, vecV8Val, errmsg));
    // fprintf(stdout, "app_obj:\n%s\n", realargs->debug_text().c_str());
    if (reqObj.method_args) delete reqObj.method_args;
    if (reqObj.method_name) delete reqObj.method_name;
    if (reqObj.service_signature) delete reqObj.service_signature;
    if (errmsg != "") {
      THROW_V8_EXCEPTION(errmsg.c_str());
    }
  }
  NanReturnValue(result);
}



NAN_METHOD(responseEncode ){
  NanScope();
  int64_t packetId = args[0]->IntegerValue();
  string *errorMsg = NULL;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    errorMsg = NULL;
  } else {
    errorMsg = new string(*v8::String::Utf8Value(args[2]));
  }
  //set hsf_response object
  hsf_response_object hsf_resp;
  hsf_resp.error_msg = errorMsg;
  hsf_resp.packet_id = packetId;
  hsf_resp.protocol = HESSIAN;
  hsf_resp.type = HSF;
  std::vector<Handle<Value> > vecVal;
  string errmsg = "";
  hsf::Object *response = v8ToHsf(args[1], vecVal, errmsg);
  if (errmsg != "") {
    if (response) {
      delete response;
    }
    THROW_V8_EXCEPTION(errmsg.c_str());
  }
  hsf_resp.method_ret = response;
  string output;
  hsf_response_encode(hsf_resp, output);
  if(hsf_resp.method_ret) {
    delete hsf_resp.method_ret;
  }
  if (hsf_resp.error_msg) {
    delete hsf_resp.error_msg;
  }
  Handle<Value> res = NEW_NODE_BUFFER(output);
  NanReturnValue(res);
}

NAN_METHOD(regist_encode ){
  NanScope();
  cs_register_object regObj;
  regObj.client_id = *v8::String::Utf8Value(args[0]);
  regObj.data_id = *v8::String::Utf8Value(args[1]);
  regObj.group = *v8::String::Utf8Value(args[2]);
  regObj.addr = *v8::String::Utf8Value(args[3]);
  string output;
  cs_register_encode(regObj, output);
  Handle<Value> res = NEW_NODE_BUFFER(output);
  NanReturnValue(res);
}

NAN_METHOD(publish_encode ){
  NanScope();
  cs_publish_object pubObj;
  pubObj.client_id = *v8::String::Utf8Value(args[0]);
  pubObj.data_id = *v8::String::Utf8Value(args[1]);
  pubObj.data = *v8::String::Utf8Value(args[2]);
  pubObj.revision = args[3]->Int32Value();
  string output;
  cs_publish_encode(pubObj, output);
  Handle<Value> res = NEW_NODE_BUFFER(output);
  NanReturnValue(res);
}

NAN_METHOD(do_publish_encode ){
  NanScope();
  Array* arr = Array::Cast(*(args[0]->ToObject()));
  std::vector<string> pubBufs;
  unsigned len = arr->Length();
  size_t size;
  const char *buf = NULL;
  for (unsigned i=0; i!=len; ++i) {
    size = Buffer::Length(arr->Get(i)->ToObject());
    buf = Buffer::Data(arr->Get(i)->ToObject());
    pubBufs.push_back(string(buf, size));
  }
  string output;
  cs_do_publish_encode(pubBufs, output);
  Handle<Value> res = NEW_NODE_BUFFER(output);
  NanReturnValue(res);
}

void InitAll(Handle<v8::Object> target) {
  target->Set(v8::String::NewSymbol("genReqBody"),
    FunctionTemplate::New(genReqBody)->GetFunction());

  target->Set(v8::String::NewSymbol("heartbeatEncode"),
    FunctionTemplate::New(heartbeatEncode)->GetFunction());

  target->Set(v8::String::NewSymbol("requestEncode"),
    FunctionTemplate::New(requestEncode)->GetFunction());

  target->Set(v8::String::NewSymbol("responseDecode"),
    FunctionTemplate::New(responseDecode)->GetFunction());

  target->Set(v8::String::NewSymbol("requestDecode"),
    FunctionTemplate::New(requestDecode)->GetFunction());

  target->Set(v8::String::NewSymbol("responseEncode"),
    FunctionTemplate::New(responseEncode)->GetFunction());

  target->Set(v8::String::NewSymbol("csRegistEncode"),
    FunctionTemplate::New(regist_encode)->GetFunction());

  target->Set(v8::String::NewSymbol("csPublishEncode"),
    FunctionTemplate::New(publish_encode)->GetFunction());

  target->Set(v8::String::NewSymbol("csDoPublishEncode"),
    FunctionTemplate::New(do_publish_encode)->GetFunction());

}

NODE_MODULE(hsfProtocol, InitAll);
