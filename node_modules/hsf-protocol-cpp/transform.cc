/*!
 * hsf - lib/hsf_protocol/hsf_transform.cc
 * Copyright(c) 2012 Taobao.com
 * Author: busi.hyy <busi.hyy@taobao.com>
 */

#include "defines.h"
#include <v8.h>
#include <typeinfo>
#include <string>
#include <map>
#include <vector>
#include <sstream>
// #include <iostream>
#include "transform.h"

#include "hsf_define.h"
#include "objects.h"
// #include "json_text.h"

using namespace v8;
using namespace hsf;
using namespace std;
using namespace node;

hsf::Object *v8ToHsf(Handle<Value> arg, vector<Handle<Value> > vecVal, string &errmsg, const bool &isArg) {
  if (errmsg != "") {
    return NULL;
  }
  hsf::Object *obj = NULL;
  if (arg->IsString()) {
    //string
    obj = new hsf::String((*v8::String::Utf8Value(arg)));
  } else if (arg->IsInt32()) {
    //int
    obj = new hsf::Integer(arg->Int32Value());
  } else if (arg->IsNumber()) {
    //number
    obj = new hsf::Double(arg->NumberValue());
  } else if (arg->IsBoolean()) {
    //boolean
    obj = new hsf::Boolean(arg->BooleanValue());
  } else if (Buffer::HasInstance(arg)) {
    //buffer
    obj = new ByteArray(Buffer::Data(arg->ToObject()), Buffer::Length(arg->ToObject()));
  } else if (arg->IsArray()) {
    //array
    for (uint32_t i = 0; i != vecVal.size(); i++) {
      if (arg->Equals(vecVal[i])) {
        errmsg = "Converting circular structure error!";
        return obj;
      }
    }
    vecVal.push_back(arg);
    List* list = new hsf::List();
    Handle<v8::Object> v8Obj = arg->ToObject();
    uint32_t  len = v8Obj->GetOwnPropertyNames()->Length();
    for (uint32_t i = 0; i != len; ++i) {
      list->push_back(v8ToHsf(v8Obj->Get(i), vecVal, errmsg), true);
    }
    obj = (hsf::Object *)list;
//if > 0.11.1, do not support isDate
#if !NODE_VERSION_AT_LEAST(0, 11, 1)
  } else if (arg->IsDate()) {
    //date
    obj = new hsf::Date((int64_t)v8::Date::Cast(*arg->ToObject())->NumberValue());
#endif

  } else if (arg->IsObject()) {
    //object
    for (uint32_t i = 0; i != vecVal.size(); i++) {
      if (arg->Equals(vecVal[i])) {
        errmsg = "Converting circular structure error!";
        return obj;
      }
    }
    vecVal.push_back(arg);
    Handle<v8::Object> v8Obj = arg->ToObject();
    if (v8Obj->Has(v8::String::New("$")) && v8Obj->Has(v8::String::New("$class"))) {
      if (!v8Obj->Get(v8::String::New("$class"))->IsString()) {
        errmsg = "$class must be type of String!";
        return NULL;
      }
      if (v8Obj->Has(v8::String::New("$abstractClass")) && !v8Obj->Get(v8::String::New("$abstractClass"))->IsString()) {
        errmsg = "$abstractClass must be type of String!";
        return NULL;
      }
      return complexV8ToHsf(v8Obj, vecVal, errmsg, isArg);
    }
    Handle<Array> keys = v8Obj->GetOwnPropertyNames();
    uint32_t len = keys->Length();
    Map* map = new hsf::Map();
    for (uint32_t i = 0; i != len; ++i) {
      map->put(*v8::String::Utf8Value(keys->Get(i)), v8ToHsf(v8Obj->Get(keys->Get(i)), vecVal, errmsg), true, true);
    }
    obj = (hsf::Object *)map;
  } else if(arg->IsNull() || arg->IsUndefined()){
    obj = new NullObject();
  } else {
    errmsg = "Yet not support this kind of struct!";
  }
  return obj;
}

hsf::Object *complexV8ToHsf(Handle<v8::Object> v8Obj, vector<Handle<Value> > vecVal, string &errmsg, const bool &isArg) {
  if (errmsg != "") {
    return NULL;
  }
  string className = *v8::String::AsciiValue(v8Obj->Get(v8::String::New("$class")));
  if (className.size() < 2) {
    errmsg = "$class must have a size bigger than 1";
    return NULL;
  }
  Handle<v8::Value> data = v8Obj->Get(v8::String::New("$"));
  if (data->IsObject()) {
    for (uint32_t i = 0; i != vecVal.size(); i++) {
      if (data->Equals(vecVal[i])) {
        errmsg = "Converting circular structure error!";
        return NULL;
      }
    }
    vecVal.push_back(data);
  }
  if (data->IsNull() || data->IsUndefined()) {
    return new NullObject(className);
  }

  if (className == "java.lang.Object") {
    if (data->IsInt32()) {
      return new hsf::Integer(data->Int32Value(), className);
    }
    if (data->IsBoolean()) {
      return new hsf::Boolean(data->BooleanValue(), className);
    }
    if (data->IsNumber()) {
      return new hsf::Double(data->NumberValue(), className);
    }
    if (data->IsString()) {
      return new hsf::String(*v8::String::Utf8Value(data), className);
    }
  }

  //long
  if (className == "java.lang.Long" || className == "long") {
    if (!data->IsNumber()) {
      errmsg = "java.lang.Long or long should be typeof Number!";
      return NULL;
    }
    return new hsf::Long((int64_t)data->NumberValue(), className);
  }
  //int short byte
  if (className == "java.lang.Short" || className == "short" ||
      className == "java.lang.Integer" || className == "int" ||
      className == "java.lang.Byte" || className == "byte") {
    if (!data->IsInt32()) {
      errmsg = "integer short byte should be typeof Integer!";
      return NULL;
    }
    return new hsf::Integer(data->Int32Value(), className);
  }
  //bool
  if (className == "java.lang.Boolean" || className == "boolean") {
    if (!data->IsBoolean()) {
      errmsg = "boolean must be typeof Boolean!";
      return NULL;
    }
    return new hsf::Boolean(data->BooleanValue(), className);
  }
  //float
  if (className == "double" || className == "java.lang.Double" ||
      className == "float" || className == "java.lang.Float") {
    if (!data->IsNumber()) {
      errmsg = "float/double must be typeof Number!";
      return NULL;
    }
    return new hsf::Double(data->NumberValue(), className);
  }
  //string
  if (className == "java.lang.String" || className == "char" ||
    className == "char[]" || className == "java.lang.Character") {
    if (!data->IsString()) {
      errmsg = "Character/String must be typeof String!";
      return NULL;
    }
    return new hsf::String(*v8::String::Utf8Value(data), className);
  }
  if (className == "java.util.ArrayList" || className == "java.util.List" ||
      className == "java.util.Set" || className == "java.util.Set" ||
      className == "java.util.Iterator" || className == "java.util.Enumeration") {
    if (!data->IsArray()) {
      errmsg = "Java List must be typeof Array!";
      return NULL;
    }
    List* list = new hsf::List(className);
    Handle<v8::Object> obj = data->ToObject();
    uint32_t  len = obj->GetOwnPropertyNames()->Length();
    for (uint32_t i = 0; i != len; ++i) {
      list->push_back(v8ToHsf(obj->Get(i), vecVal, errmsg), true);
    }
    return list;
  }
  //array
  if (className[0] == '[') {
    if (!data->IsArray()) {
      errmsg = "Java List must be typeof Array!";
      return NULL;
    }

    Handle<v8::Object> obj = data->ToObject();
    uint32_t  len = obj->GetOwnPropertyNames()->Length();
    Handle<v8::String> ckey = v8::String::New("$class");
    Handle<v8::String> vkey = v8::String::New("$");
    Handle<v8::String> cname;
    if (className == "[string") {
      cname = v8::String::New("java.lang.String");
    } else if (className == "[object") {
      cname = v8::String::New("java.lang.Object");
    } else {
      cname = v8::String::New(className.substr(1, className.size() - 1).c_str());
    }
    //如果是作为HSF服务的直接参数，数组需要表示成java的类名
    if (isArg) {
      if (className == "[short") {
        className = "[S";
      } else if (className == "[int") {
        className = "[I";
      } else if (className == "[boolean") {
        className = "[Z";
      } else if (className == "[double") {
        className = "[D";
      }  else if (className == "[long") {
        className = "[J";
      }  else if (className == "[float") {
        className = "[F";
      } else if (className == "[string") {
        className = "[Ljava.lang.String;";
      } else if (className == "[object") {
        className = "[Ljava.lang.Object;";
      } else {
        className = "[L" + className.substr(1, className.size() - 1) + ";";
      }
    }
    hsf::List* list = new hsf::List(className);
    for (uint32_t i = 0; i != len; ++i) {
      Handle<v8::Object> item = v8::Object::New();
      item->Set(ckey, cname);
      item->Set(vkey, obj->Get(i));
      list->push_back(v8ToHsf(item, vecVal, errmsg), true);
    }
    return list;
  }
  // else are map
  if (!data->IsObject()) {
    errmsg = "Java Object must be typeof Object!";
    return NULL;
  }
  hsf::Map *map = new Map(className);
  Handle<v8::Object> obj = data->ToObject();
  Handle<Array> keys = obj->GetOwnPropertyNames();
  uint32_t len = keys->Length();
  for (uint32_t i = 0; i != len; ++i) {
    map->put(*v8::String::Utf8Value(keys->Get(i)), v8ToHsf(obj->Get(keys->Get(i)), vecVal, errmsg), true, true);
  }
  if (v8Obj->Has(v8::String::New("$abstractClass"))) {
    return new hsf::Reference(map, *v8::String::AsciiValue(v8Obj->Get(v8::String::New("$abstractClass"))), true);
  } else {
    return map;
  }
}

Handle<Value> hsfToV8(hsf::Object *obj, std::vector<hsf::Object *> vecHsfVal, std::vector<Handle<Value> > vecV8Val, string &errmsg) {
  NanScope();
  Handle<Value> result = v8::Undefined();
  // bool isObject = false;
  if (errmsg != "") {
    return v8::Undefined();
  }
  // 基本类型
  if (instance_of<hsf::List> (obj)) {
    for (uint32_t i = 0; i != vecHsfVal.size(); i++) {
      if (obj == vecHsfVal[i]) {
        //errmsg = "Converting circular structure error!";
        return vecV8Val[i];
      }
    }
    vecHsfVal.push_back(obj);
    List *list = obj->to_list();
    uint32_t length = list->size();
    Handle<v8::Array> v8Arr = v8::Array::New(length);
    vecV8Val.push_back(v8Arr);
    for (uint32_t i = 0; i != length; ++i) {
      v8Arr->Set(i, hsfToV8(list->get(i), vecHsfVal, vecV8Val, errmsg));
    }
    result = v8Arr;
  } else if(instance_of<hsf::String>(obj)) {
    result = v8::String::New(obj->to_string().c_str());
  } else if (instance_of<hsf::Boolean>(obj)) {
    result = v8::Boolean::New(obj->to_bool());
  } else if (instance_of<hsf::Integer>(obj)) {
    result = v8::Number::New(obj->to_int());
  } else if (instance_of<hsf::Double>(obj)) {
    result = v8::Number::New(obj->to_double());
  }  else if (instance_of<hsf::Long>(obj)) {
    result = v8::Number::New(static_cast<double>(obj->to_long()));
  } else if (obj == NULL) {
    result = v8::Undefined();
  } else if (instance_of<hsf::Exception> (obj)) {
    hsf::Exception *ex = static_cast<hsf::Exception*>(obj);
    const string message = ex->detail_message();
    result = v8::Exception::Error(v8::String::New(message.c_str()));
    string traces = "";
    for (vector<hsf::Object*>::const_iterator it = ex->stack_trace()->data().begin();
          it != ex->stack_trace()->data().end(); ++it) {
      traces += (*it)->to_string() + '\n';
    }
    result->ToObject()->Set(v8::String::NewSymbol("javaTrace"), v8::String::New(traces.c_str()));
  } else if (instance_of<hsf::Date> (obj)) {
    result = v8::Date::New((static_cast<hsf::Date *>(obj))->data());
  } else if (instance_of<hsf::ByteArray> (obj)) {
    string buf = static_cast<hsf::ByteArray *>(obj)->data();
    result = NEW_NODE_BUFFER(buf);
  }
  else if (instance_of<hsf::Map> (obj)) {
    for (uint32_t i = 0; i != vecHsfVal.size(); i++) {
      if (obj == vecHsfVal[i]) {
        //errmsg = "Converting circular structure error!";
        return vecV8Val[i];
      }
    }
    vecHsfVal.push_back(obj);
    Handle<v8::Object> v8Obj = v8::Object::New();
    vecV8Val.push_back(v8Obj);
    const Map::data_type& data = obj->to_map()->data();
    uint32_t j = 0;
    for (Map::data_type::const_iterator it = data.begin(); it != data.end(); ++it, ++j) {
      hsf::Object* key = (*it).first;
      hsf::Object* val = (*it).second;
      v8Obj->Set(v8::String::NewSymbol(key->to_string().c_str()), hsfToV8(val, vecHsfVal, vecV8Val, errmsg));
    }
    result = v8Obj;
  } else {
    errmsg = "Yet not support this kind of struct!";
    return v8::Undefined();
  }
  return scope.Close(result);
}
