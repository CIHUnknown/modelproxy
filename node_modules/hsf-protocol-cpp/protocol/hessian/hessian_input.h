#ifndef HSF_HESSIAN_INPUT_H
#define HSF_HESSIAN_INPUT_H

#include "exceptions.h"
#include <string>
#include <stdint.h>
#include <vector>
#include <utility>
#if defined(__linux__) || defined(__GLIBC__) || defined(__GNU__)
#include <byteswap.h>
#else
 #define bswap_16(value)  \
   ((((value) & 0xff) << 8) | ((value) >> 8))

 #define bswap_32(value) \
   (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
   (uint32_t)bswap_16((uint16_t)((value) >> 16)))

 #define bswap_64(value) \
   (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
       << 32) | \
   (uint64_t)bswap_32((uint32_t)((value) >> 32)))
#endif

namespace hsf {

class Object;

/**
 * Hessian 反序列化，
 * 在输入的 data 中按照 Hessian 序列化协议读出数据
 */
class hessian_input {
public:
  hessian_input(const std::string* data);
  hessian_input(const char* data, uint32_t size);
  ~hessian_input() {}

  bool eof() const { return _curr >= _end; }

  /** 清除对象引用关系记录，但不会清除 data 内的数据 */
  void clear() { _refs_list.clear(); }

  // ---------------------------------------------------------

  void read_null();

  bool read_bool();

  int32_t read_int32();
  int64_t read_int64();

  double read_double();

  int64_t read_utc_date();

  std::string* read_utf8_string(); // 会做自动类型转换的版本
  std::string* read_chunked_utf8_string(std::string* dest = NULL);

  std::string* read_bytes();
  std::string* read_chunked_bytes(std::string* dest = NULL);

  uint32_t read_length();
  std::string read_type();

  Object* read_list(const std::string& classname = "");
  Object* read_map(const std::string& classname = "");

  // 第二个参数指示返回的对象是否新生成，需要处理 delete
  std::pair<Object*, bool> read_object();
  std::pair<Object*, bool> read_object(const std::string& classname);

  int32_t add_ref(Object* object = NULL);
  Object* read_ref();
  Object* get_ref_object(uint32_t ref_id);

  /* --------------------------------------------------------- *
   * Low level functions
   * --------------------------------------------------------- */
  uint32_t current_position() const { return _curr - _begin; }
  const char* current_ptr() const { return _curr; }
  void seek(uint32_t offset) { _curr += offset; }

  int8_t peek();
  int8_t parse_8bit();
  int16_t parse_16bit();
  int32_t parse_32bit();
  int64_t parse_64bit();

  double parse_double();

  void parse_raw_bytes(uint32_t byte_size, std::string* dest);

  void parse_utf8_string(uint32_t char_size, std::string* dest);

  // "Fast"：假定字符串里面的内容都是单字节字符，且长度不超过 0x8000 字节
  std::string* read_fast_string(std::string* dest = NULL);
  std::string read_fast_type();

  void skip_object();

private:
  io_exception expect(const std::string& expect, int ch);
  io_exception error(const std::string& expect);

private:
  const char* _begin;
  const char* _curr;
  const char* _end;

  std::vector<Object*> _refs_list;
};

inline int8_t hessian_input::peek() {
  if (_curr >= _end) {
    throw io_exception("hessian_input::peek(): will reach EOF");
  }
  return *_curr;
}

inline int8_t hessian_input::parse_8bit() {
  if (_curr >= _end) {
    throw io_exception("hessian_input::read_8bit(): will reach EOF");
  }
  return *_curr++;
}

inline int16_t hessian_input::parse_16bit() {
  if (_curr + 1 >= _end) {
    throw io_exception("hessian_input::read_16bit(): will reach EOF");
  }
  int16_t ret = bswap_16(*((uint16_t *)(_curr)));
  _curr += 2;
  return ret;
}

inline int32_t hessian_input::parse_32bit() {
  if (_curr + 3 >= _end) {
    throw io_exception("hessian_input::read_32bit(): will reach EOF");
  }
  int32_t ret = bswap_32(*((uint32_t *)(_curr)));
  _curr += 4;
  return ret;
}

inline int64_t hessian_input::parse_64bit() {
  if (_curr + 7 >= _end) {
    throw io_exception("hessian_input::read_64bit(): will reach EOF");
  }
  int64_t ret = bswap_64(*((uint64_t *)(_curr)));
  _curr += 8;
  return ret;
}

inline void hessian_input::parse_raw_bytes(uint32_t byte_size, std::string* dest) {
  if (_curr + byte_size - 1 >= _end) {
    throw io_exception("hessian_input::read_raw_bytes(): will reach EOF");
  }
  dest->append(_curr, byte_size);
  _curr += byte_size;
}

inline std::string* hessian_input::read_fast_string(std::string* dest) {
  int tag = parse_8bit();

  if (tag == 'N') {
    return dest;
  } else if (tag != 'S') {
    throw expect("fast string", tag);
  }

  uint16_t char_size = parse_16bit();
  if (_curr + char_size - 1 >= _end) {
    throw io_exception("hessian_input::read_fast_string(): will reach EOF");
  }

  if (dest == NULL) {
    dest = new std::string();
  }

  dest->append(_curr, char_size);
  _curr += char_size;
  return dest;
}

inline std::string hessian_input::read_fast_type() {
  int tag = peek();

  if (tag != 't') {
    return "";
  }

  ++_curr;
  uint16_t char_size = parse_16bit();

  std::string type;
  parse_raw_bytes(char_size, &type);
  return type;
}

}

#endif
