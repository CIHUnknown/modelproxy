#include "hessian_output.h"
#include "hessian_ext.h"
#include "objects.h"
#include "utils.h"
#include <cstring>

/*
 * Hessian 序列化实现
 * @author jifeng
 */
namespace hsf {

using namespace std;

void hessian_output::clear() {
  _refs_map.clear();
  _ref_idx = 0;
}

void hessian_output::write_null() {
  print_8bit('N');
}

void hessian_output::write_bool(bool b) {
  print_8bit(b ? 'T' : 'F');
}

void hessian_output::write_int32(int32_t value) {
  print_8bit('I');
  print_32bit(value);
}

void hessian_output::write_int64(int64_t value) {
  print_8bit('L');
  print_64bit(value);
}

void hessian_output::write_double(double d_val) {
  print_8bit('D');
  print_64bit(double_to_long(d_val));
}

void hessian_output::write_utc_date(int64_t milli_epoch) {
  print_8bit('d');
  print_64bit(milli_epoch);
}

void hessian_output::write_utf8_string(const char* str, uint32_t byte_size) {
  if (str == NULL) {
    write_null();
  }

  const uint16_t max_chunk_char_size = 0x8000;

  uint16_t char_size = 0;
  const char* curr = str;
  const char* end = str + byte_size;

  // begin new chunk
  uint32_t patch_pos = _data->length();

  _data->reserve(patch_pos + byte_size + 3);

  print_8bit('S');  // S means the last chunk
  print_16bit(max_chunk_char_size);

  unsigned char ch;
  while (curr < end) {
    print_8bit(ch = *curr++);
    if (ch & 0x80) {
      // more than one byte for this char
      if ((ch & 0xe0) == 0xc0) {
        print_8bit(*curr++);
      } else if ((ch & 0xf0) == 0xe0) {
        _data->append(curr, 2);
        curr += 2;
      } else {
        _data->append(curr, 3);
        curr += 3;
      }
    }

    ++char_size;

    if (char_size >= max_chunk_char_size) {
      // patch the chunk type from 'S' to 's'
      (*_data)[patch_pos] = 's';
      patch_pos = _data->length();

      print_8bit('S');
      print_16bit(max_chunk_char_size);

      char_size = 0;
    }
  }

  // patch the last chunk size
  (*_data)[patch_pos+1] = (char) (char_size >> 8);
  (*_data)[patch_pos+2] = (char) char_size;
}

void hessian_output::write_bytes(const char* bytes) {
  if (bytes == NULL) {
    write_null();
  }

  const uint16_t max_chunk_byte_size = 0x8000;

  const char* curr = bytes;

  // begin new chunk
  uint32_t patch_pos = _data->length();

  print_8bit('B');  // B means the last chunk
  print_16bit(max_chunk_byte_size);

  char ch;
  uint32_t byte_size = 0;
  while ((ch = *curr++) != '\0') {
    ++byte_size;
    print_8bit(ch);

    if (byte_size >= max_chunk_byte_size) {
      // patch the chunk type from 'B' to 'b'
      (*_data)[patch_pos] = 'b';
      patch_pos = _data->length();

      print_8bit('B');
      print_16bit(max_chunk_byte_size);

      byte_size = 0;
    }
  }

  // patch the last chunk size
  (*_data)[patch_pos+1] = (char) (byte_size >> 8);
  (*_data)[patch_pos+2] = (char) byte_size;
}

void hessian_output::write_bytes(const char* bytes, uint32_t byte_size) {
  if (bytes == NULL) {
    write_null();
  }

  const uint16_t max_chunk_byte_size = 0x8000;

  _data->reserve(_data->size() + byte_size + 3);

  while (byte_size > max_chunk_byte_size) {
    print_8bit('b');
    print_16bit(max_chunk_byte_size);
    print_raw_bytes(bytes, max_chunk_byte_size);

    byte_size -= max_chunk_byte_size;
    bytes += max_chunk_byte_size;
  }

  print_8bit('B');  // the last chunk
  print_16bit(byte_size);
  print_raw_bytes(bytes, byte_size);
}

void hessian_output::write_utf8_string(const string& str) {
  write_utf8_string(str.c_str(), str.size());
}

bool hessian_output::write_ref(const Object* object) {
  if (object == NULL || object->type_id() == Object::NULL_OBJECT) {
    hessian_output::write_null();
    return true;
  }
  pair<map<uintptr_t, int32_t>::iterator, bool> ret = _refs_map.insert(
      pair<uintptr_t, int32_t>((uintptr_t) object, _ref_idx));
  if (ret.second == false) {
    // ref already existed, write as a reference
    write_ref(ret.first->second);
    return true;
  } else {
    ++_ref_idx;
    return false;
  }
}

void hessian_output::write_length(uint32_t length) {
  print_8bit('l');
  print_32bit(length);
}

void hessian_output::write_type(const std::string& type) {
  print_8bit('t');
  if (type.empty()) {
    print_raw_len_bytes("", 0);
  } else {
    print_raw_len_bytes(type.c_str(), type.size());
  }
}

void hessian_output::write_ref(int32_t ref_id) {
  print_8bit('R');
  print_32bit(ref_id);
}

void hessian_output::write_object(const Object* object) {
  if (object == NULL) {
    hessian_output::write_null();
  } else if (object->type_id() <= Object::WEAK_REF || !write_ref(object)) {
    hessian_serialize_pt hs = hessian_get_serializer(object);
    if (hs) {
      hs(object, *this);
    } else {
      throw io_exception("serializer not found for object " + object->classname());
    }
  }
}

}

