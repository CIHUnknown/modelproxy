#ifndef HSF_HESSIAN_OUTPUT_H
#define HSF_HESSIAN_OUTPUT_H

#include <string>
#include <stdint.h>
#include <map>
#if defined(__linux__) || defined(__GLIBC__) || defined(__GNU__)
#include <byteswap.h>
#else
 #define bswap_16(value)  \
   ((((value) & 0xff) << 8) | ((value) >> 8))

 #define bswap_32(value) \
   (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
   (uint32_t)bswap_16((uint16_t)((value) >> 16)))

 #define bswap_64(value) \
   (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
       << 32) | \
   (uint64_t)bswap_32((uint32_t)((value) >> 32)))
#endif

namespace hsf {

class Object;

/**
 * Hessian 序列化，
 * 按照 Hessian 序列化协议往输出的 data 写数据
 */
class hessian_output {
public:
  hessian_output(std::string* data) : _data(data), _ref_idx(0) {}
  ~hessian_output() {}

  std::string* data() { return _data; }
  uint32_t size() const { return _data->size(); }

  /** 清除对象引用关系记录，但不会清除 data 内的数据 */
  void clear();

  // ---------------------------------------------------------

  void write_null();

  void write_bool(bool b);

  void write_int32(int32_t value);
  void write_int64(int64_t value);

  void write_double(double d_val);

  void write_utc_date(int64_t milli_epoch);

  void write_utf8_string(const char* str, uint32_t byte_size);
  void write_utf8_string(const std::string& str);

  void write_bytes(const char* bytes);
  void write_bytes(const char* bytes, uint32_t byte_size);

  void write_length(uint32_t length);
  void write_type(const std::string& type);

  void write_ref(int32_t ref_id);
  bool write_ref(const Object* object);
  void write_object(const Object* object);

  /* --------------------------------------------------------- *
   * Low level functions
   * --------------------------------------------------------- */
  int32_t add_ref() { return _ref_idx++; }

  void print_8bit(int8_t value) {
    _data->push_back((char) value);
  }
  void print_16bit(int16_t value) {
    _data->append((const char*)&(value = bswap_16(value)), 2);
  }
  void print_32bit(int32_t value) {
    _data->append((const char*)&(value = bswap_32(value)), 4);
  }
  void print_64bit(int64_t value) {
    _data->append((const char*)&(value = bswap_64(value)), 8);
  }

  void fill_chars(uint32_t size, char c) {
    _data->append(size, c);
  }

  void print_raw_bytes(const char* bytes, uint32_t byte_size) {
    _data->append(bytes, byte_size);
  }

  void print_raw_len_bytes(const char* bytes, uint16_t byte_size) {
    print_16bit(byte_size);
    print_raw_bytes(bytes, byte_size);
  }

  uint32_t current_position() const { return _data->length(); }
  void print_8bit_at_position(uint32_t pos, char value);
  void print_16bit_at_position(uint32_t pos, int16_t value);
  void print_32bit_at_position(uint32_t pos, int32_t value);
  void print_64bit_at_position(uint32_t pos, int64_t value);

  // "Fast"：假定字符串里面的内容都是单字节字符，且长度不超过 0x8000 字节
  void write_fast_string(const char* str, uint32_t byte_size) {
    print_8bit('S');
    print_raw_len_bytes(str, byte_size);
  }
  void write_fast_string(const std::string& str) {
    write_fast_string(str.data(), str.size());
  }
  void write_fast_type(const char* str, uint32_t byte_size) {
    print_8bit('t');
    print_raw_len_bytes(str, byte_size);
  }
  void write_fast_type(const std::string& str) {
    write_fast_type(str.data(), str.size());
  }

private:
  std::string* _data;
  std::map<uintptr_t, int32_t> _refs_map;
  int32_t _ref_idx;
};

inline void hessian_output::print_8bit_at_position(uint32_t pos, char value) {
  (*_data)[pos] = value;
}
inline void hessian_output::print_16bit_at_position(uint32_t pos, int16_t value) {
  (*_data)[  pos] = (char) (value >> 8);
  (*_data)[++pos] = (char) value;
}
inline void hessian_output::print_32bit_at_position(uint32_t pos, int32_t value) {
  (*_data)[  pos] = (char) (value >> 24);
  (*_data)[++pos] = (char) (value >> 16);
  (*_data)[++pos] = (char) (value >> 8);
  (*_data)[++pos] = (char) value;
}
inline void hessian_output::print_64bit_at_position(uint32_t pos, int64_t value) {
  (*_data)[  pos] = (char) (value >> 56);
  (*_data)[++pos] = (char) (value >> 48);
  (*_data)[++pos] = (char) (value >> 40);
  (*_data)[++pos] = (char) (value >> 32);
  (*_data)[++pos] = (char) (value >> 24);
  (*_data)[++pos] = (char) (value >> 16);
  (*_data)[++pos] = (char) (value >> 8);
  (*_data)[++pos] = (char) value;
}

}

#endif
