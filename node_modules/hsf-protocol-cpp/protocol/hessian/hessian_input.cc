#include "hessian_input.h"
#include "objects.h"
#include "hessian_ext.h"
#include "utils.h"
#include <map>
#include <sstream>
#include <memory>

/*
 * Hessian 反序列化实现
 * @author jifeng
 */
namespace hsf {

using namespace std;

hessian_input::hessian_input(const std::string* data)
  : _begin(data->c_str()), _curr(_begin), _end(_begin + data->length()) {}

hessian_input::hessian_input(const char* data, uint32_t size)
  : _begin(data), _curr(data), _end(data + size) {}

void hessian_input::read_null() {
  int tag = parse_8bit();
  if (tag != 'N') {
    throw expect("null", tag);
  }
}

bool hessian_input::read_bool() {
  int tag = parse_8bit();

  switch (tag) {
  case 'T': return true;
  case 'F': return false;
  case 'I': return parse_32bit() == 0;
  case 'L': return parse_64bit() == 0;
  case 'D': return parse_double() == 0.0;
  case 'N': return false;
  default:
    throw expect("bool", tag);
  }
}

int32_t hessian_input::read_int32() {
  int tag = parse_8bit();
  switch (tag) {
  case 'I': return parse_32bit();
  case 'T': return 1;
  case 'F': return 0;
  case 'L': return (int) parse_64bit();
  case 'D': return (int) parse_double();
  default:
    throw expect("int", tag);
  }
}

int64_t hessian_input::read_int64() {
  int tag = parse_8bit();
  switch (tag) {
  case 'L': return parse_64bit();
  case 'T': return 1L;
  case 'F': return 0L;
  case 'I': return (long) parse_32bit();
  case 'D': return (long) parse_double();
  default:
    throw expect("long", tag);
  }
}

double hessian_input::read_double() {
  int tag = parse_8bit();
  switch (tag) {
  case 'D': return parse_double();
  case 'T': return 1;
  case 'F': return 0;
  case 'I': return (double) parse_32bit();
  case 'L': return (double) parse_64bit();
  default:
    throw expect("double", tag);
  }
}

int64_t hessian_input::read_utc_date() {
  int tag = parse_8bit();
  if (tag != 'd') {
    throw expect("date", tag);
  }
  return parse_64bit();
}

string* hessian_input::read_utf8_string() {
  int tag = parse_8bit();
  switch (tag) {
  case 'S':
  case 's':
    --_curr;
    return read_chunked_utf8_string();
  case 'N':
    return NULL;
  case 'I':
    return new string(int32_to_string(parse_32bit()));
  case 'L':
    return new string(int64_to_string(parse_64bit()));
  case 'D':
    return new string(double_to_string(parse_double()));
  default:
    throw expect("string", tag);
  }
}

string* hessian_input::read_chunked_utf8_string(string* dest) {
  int tag = parse_8bit();

  if (tag == 'N') {
    return dest;
  }

  auto_ptr<string> safeguard;
  if (dest == NULL) {
    dest = new string();
    safeguard.reset(dest); // 确保在后续操作抛出异常时释放
  }

  while (tag == 's') {
    uint16_t char_size = parse_16bit();
    parse_utf8_string(char_size, dest);
    tag = parse_8bit();
  }

  if (tag == 'S') {
    uint16_t char_size = parse_16bit();
    parse_utf8_string(char_size, dest);
    safeguard.release();
    return dest;
  } else {
    throw expect("string", tag);
  }
}

string* hessian_input::read_bytes() {
  int tag = peek();
  switch (tag) {
  case 'B':
  case 'b':
    return read_chunked_bytes();
  case 'N':
    ++_curr;
    return NULL;
  default:
    throw expect("bytes", tag);
  }
}

string* hessian_input::read_chunked_bytes(string* dest) {
  int tag = parse_8bit();

  if (tag == 'N') {
    return dest;
  }

  auto_ptr<string> safeguard;
  if (dest == NULL) {
    dest = new string();
    safeguard.reset(dest); // 确保在后续操作抛出异常时释放
  }

  while (tag == 'b') {
    uint16_t byte_size = parse_16bit();
    parse_raw_bytes(byte_size, dest);
    tag = parse_8bit();
  }

  if (tag == 'B') {
    uint16_t byte_size = parse_16bit();
    parse_raw_bytes(byte_size, dest);
    safeguard.release();
    return dest;
  } else {
    throw expect("bytes", tag);
  }
}

uint32_t hessian_input::read_length() {
  int tag = parse_8bit();
  if (tag != 'l') {
    --_curr;
    return 0xFFFFFFFF;
  }
  return parse_32bit();
}

string hessian_input::read_type() {
  int tag = parse_8bit();
  if (tag != 't') {
    --_curr;
    return "";
  }
  uint16_t char_size = parse_16bit();

  string type;
  parse_utf8_string(char_size, &type);

  return type;
}

Object* hessian_input::read_list(const string& classname) {
  int tag = parse_8bit();

  switch (tag) {
  case 'V': break;
  case 'N': return NULL;
  case 'R': return get_ref_object(parse_32bit());
  default: throw expect("list", tag);
  }

  string type = read_fast_type();
  if (type.empty()) {
    type = classname.empty() ? List::DEFAULT_CLASSNAME : classname;
  }

  hessian_deserialize_pt ext = hessian_get_deserializer(Object::EXT_LIST, type);

  if (ext) {
    return ext(type, *this);

  } else {
    List* list = new List(type);
    auto_ptr<List> safeguard(list); // 确保在后续操作抛出异常时释放
    add_ref(list);

    uint32_t length = read_length();
    if (length != 0xFFFFFFFF) {
      list->reserve(length);
    }

    if (!type.empty() && type[0] == '[') {
      // multidimension array, we know sub_type name
      const string& sub_type = (type == "[string")
          ? String::DEFAULT_CLASSNAME // 对 "[string" 处理为 "[java.lang.String"
          : type.substr(1);

      while ((tag = peek()) != 'z') {
        pair<Object*, bool> ret = read_object(sub_type);
        list->push_back_ptr(ret.first, ret.second);
      }
    } else {
      while ((tag = peek()) != 'z') {
        pair<Object*, bool> ret = read_object();
        list->push_back_ptr(ret.first, ret.second);
      }
    }

    ++_curr;
    safeguard.release();
    return list;
  }
}

Object* hessian_input::read_map(const string& classname) {
  int tag = parse_8bit();

  switch (tag) {
  case 'M': break;
  case 'N': return NULL;
  case 'R': return get_ref_object(parse_32bit());
  default: throw expect("map", tag);
  }

  string type = read_fast_type();
  if (type.empty()) {
    type = classname.empty() ? Map::DEFAULT_CLASSNAME : classname;
  }

  hessian_deserialize_pt ext = hessian_get_deserializer(Object::EXT_MAP, type);

  if (ext) {
    return ext(type, *this);
  } else {
    Map* map = new Map(type);
    auto_ptr<Map> safeguard(map); // 确保在后续操作抛出异常时释放
    add_ref(map);

    while ((tag = peek()) != 'z') {
      pair<Object*, bool> ret_key = read_object();
      pair<Object*, bool> ret_val = read_object();
      map->put(ret_key.first, ret_val.first, ret_key.second, ret_val.second);
    }

    ++_curr;
    safeguard.release();
    return map;
  }
}

pair<Object*, bool> hessian_input::read_object() {
  int tag = parse_8bit();

  switch (tag) {
  case 'N': return pair<Object*, bool>(NULL, false);
  case 'T': return pair<Object*, bool>(new Boolean(true), true);
  case 'F': return pair<Object*, bool>(new Boolean(false), true);
  case 'I': return pair<Object*, bool>(new Integer(parse_32bit()), true);
  case 'L': return pair<Object*, bool>(new Long(parse_64bit()), true);
  case 'D': return pair<Object*, bool>(new Double(parse_double()), true);
  case 'd': return pair<Object*, bool>(new Date(parse_64bit()), true);
  case 's':
  case 'S': --_curr; return pair<Object*, bool>(new String(read_chunked_utf8_string(), true), true);
  case 'b':
  case 'B': --_curr; return pair<Object*, bool>(new ByteArray(read_chunked_bytes(), true), true);
  case 'V': --_curr; return pair<Object*, bool>(read_list(), true);
  case 'M': --_curr; return pair<Object*, bool>(read_map(), true);
  case 'R': return pair<Object*, bool>(get_ref_object(parse_32bit()), false);
  default:
    throw io_exception("unsupported code");
  }
}

pair<Object*, bool> hessian_input::read_object(const string& classname) {
  int tag = parse_8bit();

  switch (tag) {
  case 'N': return pair<Object*, bool>(NULL, false);
  case 'T': return pair<Object*, bool>(new Boolean(true, classname), true);
  case 'F': return pair<Object*, bool>(new Boolean(false, classname), true);
  case 'I': return pair<Object*, bool>(new Integer(parse_32bit(), classname), true);
  case 'L': return pair<Object*, bool>(new Long(parse_64bit(), classname), true);
  case 'D': return pair<Object*, bool>(new Double(parse_double(), classname), true);
  case 'd': return pair<Object*, bool>(new Date(parse_64bit(), classname), true);
  case 's':
  case 'S': --_curr; return pair<Object*, bool>(new String(read_chunked_utf8_string(), true, classname), true);
  case 'b':
  case 'B': --_curr; return pair<Object*, bool>(new ByteArray(read_chunked_bytes(), true, classname), true);
  case 'V': --_curr; return pair<Object*, bool>(read_list(classname), true);
  case 'M': --_curr; return pair<Object*, bool>(read_map(classname), true);
  case 'R': return pair<Object*, bool>(get_ref_object(parse_32bit()), false);
  default:
    throw error("unsupported code");
  }
}

int32_t hessian_input::add_ref(Object* object) {
  _refs_list.push_back(object);
  return _refs_list.size();
}

Object* hessian_input::read_ref() {
  int tag = parse_8bit();
  if (tag != 'R') {
    throw expect("reference", tag);
  }
  return get_ref_object(parse_32bit());
}

Object* hessian_input::get_ref_object(uint32_t ref_id) {
  if (ref_id >= _refs_list.size()) {
    ostringstream oss;
    oss << "the given reference (ref_id=" << ref_id
        << ") is not in the _refs_list (size=" << _refs_list.size() << ")";
    throw error(oss.str());
  }
  return _refs_list[ref_id];
}

double hessian_input::parse_double() {
  return long_to_double(parse_64bit());
}

void hessian_input::parse_utf8_string(uint32_t char_size, string* dest) {
  if (_curr + char_size - 1 >= _end) {
    throw error("hessian_input::parse_utf8_string(): will reach EOF");
  }

  dest->reserve(dest->size() + char_size);

  while (char_size--) {
    if (eof()) {
      throw error("hessian_input::parse_utf8_string(): reached EOF");
    }

    int ch = (uint8_t) *_curr++;

    if (ch < 0x80) {
      dest->push_back(ch);
    } else if ((ch & 0xe0) == 0xc0) {
      dest->push_back(ch);
      dest->push_back(*_curr++);
    } else if ((ch & 0xf0) == 0xe0) {
      dest->push_back(ch);
      dest->push_back(*_curr++);
      dest->push_back(*_curr++);
    } else {
      throw error("bad utf-8 encoding");
    }
  }
}

void hessian_input::skip_object() {
  pair<Object*, bool> ret = read_object();
  if (ret.second) {
    delete ret.first;
  }
}

io_exception hessian_input::expect(const string& expect, int ch) {
  ostringstream oss;
  oss << "expected " << expect;
  if (ch < 0) {
    oss << " but reached end of file";
  } else {
    oss << " but actually met " << hex << showbase << ch;
  }
  oss << " near position " << (uintptr_t)(_curr - _begin);
  return io_exception(oss.str());
}

io_exception hessian_input::error(const string& expect) {
  ostringstream oss;
  oss << "error: " << expect << " near position " << (uintptr_t)(_curr - _begin);
  return io_exception(oss.str());
}

}

