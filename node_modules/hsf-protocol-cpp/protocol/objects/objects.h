#ifndef HSF_OBJECTS_H
#define HSF_OBJECTS_H

#include "exceptions.h"
#include <string>
#include <stdint.h>
#include <vector>
#include <map>
#include <iosfwd>

namespace hsf {

class List;
class Map;
class ObjectValue;

class Object {
public:
  /**
   * 对象类型
   */
  typedef enum ObjectType {
    NULL_OBJECT = 0,                      // 空对象
    BOOLEAN, INTEGER, LONG, DOUBLE, DATE, // 基本类型
    STRING, BYTE_ARRAY,                   // 基于字符和字节的数组
    WEAK_REF,                             // 弱对象，不会被链式删除

    // 以下对象均需要在序列化时产生引用
    LIST,                                 // 数组、列表、集合、线性迭代器
    MAP,                                  // 关联表、哈希表、一般对象
    // 以下为扩展类型
    EXT_OBJECT = MAP + 1,                 // 扩展对象（基于序列化协议）
    EXT_LIST = 100,                       // 扩展对象（基于列表）
    EXT_MAP = 200,                        // 扩展对象（基于关联表）
    EXCEPTION                             // 异常类型
  } ObjectType;

  Object(const std::string& classname, uint32_t type_id)
    : _type_id(type_id), _classname(classname) {}

  virtual ~Object() {}

  /** 取得对象类型 */
  uint32_t type_id() const { return _type_id; }

  /** 对象的类名 */
  const std::string& classname() const { return _classname; }
  void set_classname(const std::string& classname) { _classname = classname; }

  /*
   * 将对象转换为基本类型（支持弱类型转换，如 long->int 等），
   * 转换失败时会抛出异常
   */
  bool to_bool() const throw(class_cast_exception);
  int32_t to_int() const throw(class_cast_exception);
  int64_t to_long() const throw(class_cast_exception);
  double to_double() const throw(class_cast_exception);
  std::string to_string() const throw(class_cast_exception);
  List* to_list() throw(class_cast_exception);
  Map* to_map() throw(class_cast_exception);

  /** 输出对象调试信息 */
  std::string debug_text() const;

  /** 产生扩展对象的 type_id */
  static uint32_t generate_type_id(ObjectType ext_type);

private:
  const uint32_t _type_id;

protected:
  std::string _classname;

private:
  Object(const Object& other);
  Object& operator=(const Object& other);
};

/** 输出对象调试信息到指定流 */
std::ostream& operator << (std::ostream& os, const Object& obj);

template <class T>
inline bool instance_of(const Object* obj) {
  return obj && obj->type_id() == T::TYPE_ID;
}

template <class T>
inline bool pointer_of(const Object* obj) {
  return !obj || obj->type_id() == T::TYPE_ID;
}

/**
 * null 引用，可用空指针 <code>(Object*) NULL</code> 替代
 */
class NullObject : public Object {
public:
  typedef void* data_type;
  static const uint32_t TYPE_ID = NULL_OBJECT;
  NullObject(const std::string& classname = "null") : Object(classname, TYPE_ID) {}

  bool is_null() const { return true; }
  data_type data() const { return NULL; }
};

/**
 * 布尔类型，对应 Java 中的 boolean/Boolean
 */
class Boolean : public Object {
public:
  typedef bool data_type;
  static const uint32_t TYPE_ID = BOOLEAN;
  static const std::string DEFAULT_CLASSNAME;

  Boolean(data_type value, const std::string& classname = DEFAULT_CLASSNAME)
    : Object(classname, TYPE_ID), _value(value) {}

  bool to_bool() const { return _value; }
  data_type data() const { return _value; }
protected:
  data_type _value;
};

/**
 * 32位整型，对应 Java 中的 byte/int/Integer/short/Short
 */
class Integer : public Object {
public:
  typedef int32_t data_type;
  static const uint32_t TYPE_ID = INTEGER;
  static const std::string DEFAULT_CLASSNAME;

  Integer(data_type value, const std::string& classname = DEFAULT_CLASSNAME)
    : Object(classname, TYPE_ID), _value(value) {}

  int32_t to_int() const { return _value; }
  data_type data() const { return _value; }
protected:
  data_type _value;
};

/**
 * 64位长整型，对应 Java 中的 long/Long
 */
class Long : public Object {
public:
  typedef int64_t data_type;
  static const uint32_t TYPE_ID = LONG;
  static const std::string DEFAULT_CLASSNAME;

  Long(data_type value, const std::string& classname = DEFAULT_CLASSNAME)
    : Object(classname, TYPE_ID), _value(value) {}

  int64_t to_long() const { return _value; }
  data_type data() const { return _value; }
protected:
  data_type _value;
};

/**
 * 64位浮点类型，对应 Java 中的 double/Double/float/Float
 */
class Double : public Object {
public:
  typedef double data_type;
  static const uint32_t TYPE_ID = DOUBLE;
  static const std::string DEFAULT_CLASSNAME;

  Double(data_type value, const std::string& classname = DEFAULT_CLASSNAME)
    : Object(classname, TYPE_ID), _value(value) {}

  double to_double() const { return _value; }
  data_type data() const { return _value; }
protected:
  data_type _value;
};

/**
 * 64位日期/时间类型，对应 Java 中的 java.util.Date。
 * 距 UTC 1970年1月1日零点的毫秒数
 */
class Date : public Object {
public:
  typedef int64_t data_type;
  static const uint32_t TYPE_ID = DATE;
  static const std::string DEFAULT_CLASSNAME;

  Date(data_type value, const std::string& classname = DEFAULT_CLASSNAME)
    : Object(classname, TYPE_ID), _value(value) {}

  int64_t to_udc_date() const { return _value; }
  data_type data() const { return _value; }
protected:
  data_type _value;
};

/**
 * 字符类型，对应 Java 中的 char/String/char[]/Character
 */
class String : public Object {
public:
  typedef std::string data_type;
  static const uint32_t TYPE_ID = STRING;
  static const std::string DEFAULT_CLASSNAME;

  String(const char* utf_8_c_str, uint32_t size,
         const std::string& classname = DEFAULT_CLASSNAME);

  String(const char* utf_8_c_str,
         const std::string& classname = DEFAULT_CLASSNAME);

  String(const std::string& utf_8_str,
         const std::string& classname = DEFAULT_CLASSNAME);

  String(const std::string* utf_8_str_ptr,
         const std::string& classname = DEFAULT_CLASSNAME);

  String(std::string* utf_8_str_ptr, bool chain_delete = false,
         const std::string& classname = DEFAULT_CLASSNAME);

  virtual ~String();

  uint32_t size() const { return _str->size(); }

  std::string to_string() const { return *_str; };
  const data_type& data() const { return *_str; }

  /**
   * 将包含的字符串指针返回，并使之不会被 String 回收时链式回收。
   * 调用者需要保证回收返回的指针指向的内存。如果该字符串不是由
   * String 链式回收，将返回 NULL
   */
  std::string* detach();
protected:
  std::string* _str;
private:
  bool _chain_delete;
};

/**
 * 字节类型，对应 Java 中的 byte[]/Byte，记作“[B”
 */
class ByteArray : public Object {
public:
  typedef std::string data_type;
  static const uint32_t TYPE_ID = BYTE_ARRAY;
  static const std::string DEFAULT_CLASSNAME;

  ByteArray(const char* bytes, uint32_t size,
            const std::string& classname = DEFAULT_CLASSNAME);

  ByteArray(const char* bytes,
            const std::string& classname = DEFAULT_CLASSNAME);

  ByteArray(const std::string& byte_str,
            const std::string& classname = DEFAULT_CLASSNAME);

  ByteArray(const std::string* byte_str_ptr,
            const std::string& classname = DEFAULT_CLASSNAME);

  ByteArray(std::string* byte_str_ptr, bool chain_delete = false,
            const std::string& classname = DEFAULT_CLASSNAME);

  virtual ~ByteArray();

  uint32_t size() const { return _str->size(); }

  std::string to_string() const { return *_str; }
  const data_type& data() const { return *_str; }

  /**
   * 将包含的字符串指针返回，并使之不会被 ByteArray 回收时链式回收。
   * 调用者需要保证回收返回的指针指向的内存。如果该字符串不是由
   * ByteArray 链式回收，将返回 NULL
   */
  std::string* detach();
protected:
  std::string* _str;
private:
  bool _chain_delete;
};

/**
 * 引用类型，一般情况下可以直接使用 Object* 替代。
 * 用于解决传递抽象类以及资源回收等问题
 */
class Reference : public Object {
public:
  typedef Object* data_type;
  static const uint32_t TYPE_ID = WEAK_REF;

  Reference(data_type value)
    : Object(value->classname(), TYPE_ID), _value(value), _chain_delete(false) {}
  Reference(data_type value, const std::string& classname, bool chain_delete = false)
    : Object(classname, TYPE_ID), _value(value), _chain_delete(chain_delete) {}

  ~Reference() { if (_chain_delete) delete _value; }

  data_type data() const { return _value; }
  data_type detach() { _chain_delete = false; return _value; }
protected:
  data_type _value;
  bool      _chain_delete;
};

/**
 * 数组类型，对应 Java 中除了 char[] 与 byte[] 以外的各种数组，
 * 以及 Collection/List/Set/Iterator/Enumeration。
 *
 * 对象数组的类名形如：“[Ljava.lang.Class;”，“[Ljava.lang.Object;”，“[Ljava.lang.String;”
 * 会被记做：“[java.lang.Class”，“[object”，“[string”，
 * 需要注意区别，必要时要用 Reference 替换类名。
 *
 * 对于多维数组的情况，每一维都带有一个前缀“[”。如：“[[int”，表示“int[][]”
 */
class List : public Object {
public:
  typedef std::vector<Object*> data_type;
  static const uint32_t TYPE_ID = LIST;
  static const std::string DEFAULT_CLASSNAME;

  List(const std::string& classname = DEFAULT_CLASSNAME, uint32_t type_id = TYPE_ID)
      : Object(classname, type_id) {}
  virtual ~List();

  void push_back_ptr(Object* element, bool chain_delete = false);
  void push_back(const ObjectValue& element, bool chain_delete = false);
  void add(const ObjectValue& element, bool chain_delete = false);
  void set(uint32_t pos, const ObjectValue& value, bool chain_delete = false);
  Object* get(uint32_t pos) const;

  const data_type& data() const { return _list; }

  uint32_t size() const { return _list.size(); }
  void reserve(uint32_t n) { _list.reserve(n); }

  // use operator[] for query purpose only
  Object* operator[] (uint32_t pos) const;

  /**
   * 将 detachment 从 List 的 chain_delete 表中移除，使之不会被链式回收
   * 调用者需要保证回收 detachment 指向的内存。如果 detachment 不是由
   * List 链式回收，将返回 false。成功 detach 返回 true
   */
  bool detach(Object* detachment);
protected:
  data_type _list;
  std::vector<Object*> _delete_chain;
};

template <>
inline bool instance_of<List>(const Object* obj) {
  return obj && (obj->type_id() == List::TYPE_ID ||
                 (obj->type_id() >= Object::EXT_LIST && obj->type_id() < Object::EXT_MAP));
}

template <>
inline bool pointer_of<List>(const Object* obj) {
  return !obj || (obj->type_id() == List::TYPE_ID ||
                  (obj->type_id() >= Object::EXT_LIST && obj->type_id() < Object::EXT_MAP));
}

/**
 * 在 Map 中使用的 Object* 比较器
 */
class object_ptr_less_comparator {
public:
  bool operator() (const Object* const &left, const Object* const &right) const;
};

/**
 * 关联表类型，对应 Java 中的 Map 类型，以及所有常规对象
 */
class Map : public Object {
public:
  typedef std::map<Object*, Object*, object_ptr_less_comparator> data_type;
  static const uint32_t TYPE_ID = MAP;
  static const std::string DEFAULT_CLASSNAME;

  Map(const std::string& classname = DEFAULT_CLASSNAME, uint32_t type_id = TYPE_ID)
      : Object(classname, type_id) {}
  virtual ~Map();

  void put(Object* key, Object* value,
           bool chain_delete_key = false, bool chain_delete_value = false);
  void put(const ObjectValue& key, const ObjectValue& value,
           bool chain_delete_key = false, bool chain_delete_value = false);
  Object* get(const ObjectValue& key) const;
  Object* get(const char* c_str_key) const;  // 针对常见用法优化性能
  Object* get_ptr(Object* const key) const;

  const data_type& data() const { return _map; }

  uint32_t size() const { return _map.size(); }

  // use operator[] for query purpose only
  Object* operator[](const ObjectValue& key) const;

  /**
   * 将 detachment 从 Map 的 chain_delete 表中移除，使之不会被链式回收。
   * 调用者需要保证回收 detachment 指向的内存。如果 detachment 不是由
   * Map 链式回收，将返回 false。成功 detach 返回 true
   */
  bool detach(Object* detachment);
protected:
  data_type _map;
  std::vector<Object*> _delete_chain;
};

template <>
inline bool instance_of<Map>(const Object* obj) {
  return obj && (obj->type_id() == Map::TYPE_ID || obj->type_id() >= Object::EXT_MAP);
}

template <>
inline bool pointer_of<Map>(const Object* obj) {
  return !obj || (obj->type_id() == Map::TYPE_ID || obj->type_id() >= Object::EXT_MAP);
}

/**
 * 提供将基础类型自动转换为 Object* 的功能
 */
class ObjectValue {
public:
  ObjectValue(bool    bval) : _type(BVAL) { _value.bval = bval; }
  ObjectValue(int8_t  cval) : _type(CVAL) { _value.cval = cval; }
  ObjectValue(int16_t sval) : _type(SVAL) { _value.sval = sval; }
  ObjectValue(int32_t ival) : _type(IVAL) { _value.ival = ival; }
  ObjectValue(int64_t lval) : _type(LVAL) { _value.lval = lval; }
  ObjectValue(double  dval) : _type(DVAL) { _value.dval = dval; }

  ObjectValue(const char* c_char_ptr) : _type(C_CHAR_PTR) { _value.c_char_ptr = c_char_ptr; }
  ObjectValue(const std::string& str) : _type(C_STR_REF) { _value.c_str_ptr = &str; }
  ObjectValue(const std::string* c_str_ptr) : _type(C_STR_PTR) { _value.c_str_ptr = c_str_ptr; }
  ObjectValue(std::string* str_ptr) : _type(STR_PTR) { _value.str_ptr = str_ptr; }

  ObjectValue(Object* obj) : _type(OBJ) { _value.obj = obj; }
  ObjectValue(const Object* c_obj) : _type(C_OBJ) { _value.c_obj = c_obj; }

  /**
   * 返回 ObjectValue 对应的 Object，
   * 第二个参数用于标识这个 Object 是否应该被链式释放
   */
  std::pair<Object*, bool> get_object() const;

private:
  union {
    bool    bval;
    int8_t  cval;
    int16_t sval;
    int32_t ival;
    int64_t lval;
    double  dval;

    const char*   c_char_ptr;
    const std::string* c_str_ptr;
    std::string*       str_ptr;
    Object*       obj;
    const Object* c_obj;
  } _value;

  enum object_data_type {
    BVAL, CVAL, SVAL, IVAL, LVAL, DVAL,
    C_CHAR_PTR, C_STR_REF, C_STR_PTR, STR_PTR,
    OBJ, C_OBJ
  } _type;
};

/* ============================================================================
 * 扩展的 Java 对象
 * ========================================================================= */
/**
 * 异常对象
 */
class Exception : public Map {
public:
  static const std::string DEFAULT_CLASSNAME;
  static const uint32_t TYPE_ID = EXCEPTION;

  Exception(const std::string& detail_message = "", const std::string& classname = DEFAULT_CLASSNAME)
      : Map(classname, TYPE_ID), _detail_message(detail_message),
        _stack_trace(NULL), _cause(NULL) {}
  virtual ~Exception() {}

  const char* what() const throw() { return _detail_message.c_str(); }

  void set_cause(Exception* cause, bool chain_delete = false) {
    _cause = cause; if (cause && chain_delete) _delete_chain.push_back(cause); }
  const Exception* cause() const { return _cause; }

  void set_detail_message(const std::string& message) { _detail_message = message; }
  std::string* mutable_detail_message() { return &_detail_message; }
  const std::string& detail_message() const { return _detail_message; }

  void set_stack_trace(List* stack_trace, bool chain_delete = false) {
    _stack_trace = stack_trace; if (stack_trace && chain_delete) _delete_chain.push_back(stack_trace); }
  const List* stack_trace() const { return _stack_trace; }

protected:
  std::string _detail_message;
  List*       _stack_trace; // List<String*>*
  Exception*  _cause;
};

/**
 * 将普通的 C/C++ 类型包装为 Object
 */
template <class T>
class ExtObject : public Object {
public:
  typedef T data_type;
  static const uint32_t TYPE_ID;
  static const std::string DEFAULT_CLASSNAME;

  ExtObject(T* ptr,
            bool chain_delete = false,
            const std::string& classname = DEFAULT_CLASSNAME)
      : Object(classname, TYPE_ID), _ptr(ptr), _chain_delete(chain_delete) {}

  ~ExtObject() { if (_chain_delete) delete _ptr; }

  T* data() const { return _ptr; }
  void set_data(T* ptr) { if (_chain_delete) { delete _ptr; } _ptr = ptr; }
protected:
  T*   _ptr;
  bool _chain_delete;
};

}
#endif
