#include "hsf_define.h"
#include "hessian_protoc.h"
#include "hessian_input.h"
#include "hessian_output.h"
#include "tb_remoting.h"
/*
 * tb-remoting / HSF 对象的 Hessian 序列化器实现
 * @author jifeng
 */
namespace hsf {

using namespace std;

/*
 * connection_request
 */
void hessian_encode_connection_request(remoting_packet* opacket) {
  hessian_output hout(opacket->data);
  static char conn_request[] = {
    'M', 't', 0x0, CONNECTION_REQUEST_CLASSNAME_SIZE,
        'c', 'o', 'm', '.', 't', 'a', 'o', 'b',
        'a', 'o', '.', 'r', 'e', 'm', 'o', 't',
        'i', 'n', 'g', '.', 'i', 'm', 'p', 'l',
        '.', 'C', 'o', 'n', 'n', 'e', 'c', 't',
        'i', 'o', 'n', 'R', 'e', 'q', 'u', 'e',
        's', 't',
    'S', 0x0, 0x3, 'c', 't', 'x',
    'M', 't', 0x0, sizeof(CONNECTION_REQUEST_CLASSNAME "$RequestContext") - 1,
        'c', 'o', 'm', '.', 't', 'a', 'o', 'b',
        'a', 'o', '.', 'r', 'e', 'm', 'o', 't',
        'i', 'n', 'g', '.', 'i', 'm', 'p', 'l',
        '.', 'C', 'o', 'n', 'n', 'e', 'c', 't',
        'i', 'o', 'n', 'R', 'e', 'q', 'u', 'e',
        's', 't', '$', 'R', 'e', 'q', 'u', 'e',
        's', 't', 'C', 'o', 'n', 't', 'e', 'x',
        't',
    'S', 0x0, sizeof("id") - 1,
        'i', 'd',
    'L'
  };
  hout.print_raw_bytes(conn_request, sizeof(conn_request));
  hout.print_64bit(opacket->packet_id);
  hout.print_8bit('z');
  hout.print_8bit('z');
}

void hessian_decode_connection_request(remoting_packet* ipacket) {
  hessian_input hin(ipacket->input, ipacket->conn_len);
  hin.seek(4 + CONNECTION_REQUEST_CLASSNAME_SIZE);
  hin.add_ref();

  int tag, len;
  while ((tag = hin.parse_8bit()) == 'S') {
    switch (len = hin.parse_16bit()) { // read field name's length
    case 3: // ctx
      // 跳过 3 个字节 field 名，4 个字节 M t b16 b8，以及类名
      hin.seek(3 + 4 + sizeof(CONNECTION_REQUEST_CLASSNAME "$RequestContext") - 1);
      hin.add_ref();
      while ((tag = hin.parse_8bit()) == 'S') {
        switch (len = hin.parse_16bit()) {
        case 2: // id
          hin.seek(2);
          ipacket->packet_id = hin.read_int64();
          return;
        case 6: // this$0
          hin.seek(6 + 5); // 跳过 field 名和 R b32 b24 b16 b8
          break;
        default:
          hin.seek(len);
          hin.skip_object();
        }
      }
      if (tag != 'z') {
        throw io_exception("fail to parse ConnectionRequest, expecting 'z' for ctx");
      }
      break;
    default:
      hin.seek(len);
      hin.skip_object();
    }
  }
  if (tag != 'z') {
    throw io_exception("fail to parse ConnectionRequest, expecting 'z'");
  }
  ipacket->error_msg = new string("fail to get packet_id from ConnectionRequest");
}

/*
 * connection_response
 */
void hessian_encode_connection_response(remoting_packet* opacket) {
  hessian_output hout(opacket->data);
  static char segment[] = {
    'M', 't', 0x0, CONNECTION_RESPONSE_CLASSNAME_SIZE,
        'c', 'o', 'm', '.', 't', 'a', 'o', 'b',
        'a', 'o', '.', 'r', 'e', 'm', 'o', 't',
        'i', 'n', 'g', '.', 'i', 'm', 'p', 'l',
        '.', 'C', 'o', 'n', 'n', 'e', 'c', 't',
        'i', 'o', 'n', 'R', 'e', 's', 'p', 'o',
        'n', 's', 'e',
    'S', 0x0, 0x3, 'c', 't', 'x',
    'M', 't', 0x0, sizeof(CONNECTION_RESPONSE_CLASSNAME "$ResponseContext") - 1,
        'c', 'o', 'm', '.', 't', 'a', 'o', 'b',
        'a', 'o', '.', 'r', 'e', 'm', 'o', 't',
        'i', 'n', 'g', '.', 'i', 'm', 'p', 'l',
        '.', 'C', 'o', 'n', 'n', 'e', 'c', 't',
        'i', 'o', 'n', 'R', 'e', 's', 'p', 'o',
        'n', 's', 'e', '$', 'R', 'e', 's', 'p',
        'o', 'n', 's', 'e', 'C', 'o', 'n', 't',
        'e', 'x', 't',
    'S', 0x0, sizeof("id") - 1,
        'i', 'd',
    'L'
  };
  hout.print_raw_bytes(segment, sizeof(segment));

  // packet_id
  hout.print_64bit(opacket->packet_id);
  hout.print_8bit('z');

  if (opacket->error_msg) {
    hout.write_fast_string(CONST_C_STRING("errorMsg"));
    hout.write_utf8_string(*opacket->error_msg);
  }
  hout.print_8bit('z');
}

void hessian_decode_connection_response(remoting_packet* ipacket) {
  hessian_input hin(ipacket->input, ipacket->conn_len);
  hin.seek(4 + CONNECTION_RESPONSE_CLASSNAME_SIZE);
  hin.add_ref();

  int tag, len;
  string error_msg, error_stack;
  while ((tag = hin.parse_8bit()) == 'S') {
    switch (len = hin.parse_16bit()) { // read field name's length
    case 3: // ctx
      // 跳过 3 个字节 field 名，4 个字节 M t b16 b8，以及类名
      hin.seek(3 + 4 + sizeof(CONNECTION_RESPONSE_CLASSNAME "$ResponseContext") - 1);
      hin.add_ref();
      while ((tag = hin.parse_8bit()) == 'S') {
        switch (len = hin.parse_16bit()) {
        case 2: // id
          hin.seek(2);
          ipacket->packet_id = hin.read_int64();
          break;
        case 6: // this$0
          hin.seek(6 + 5); // 跳过 field 名和 R b32 b24 b16 b8
          break;
        default:
          hin.seek(len);
          hin.skip_object();
        }
      }
      if (tag != 'z') {
        throw io_exception("fail to parse ConnectionResponse$ResponseContext, expecting 'z' for ctx");
      }
      break;
    case 4: // host
      hin.seek(4);
      if (hin.parse_8bit() == 'S') {
        hin.seek(hin.parse_16bit()); // 跳过其内容
      }
      // 还有一种情况是 'N'，后续没有数据
      break;
    case 6: // result
      hin.seek(6 + 1 + 4); // 跳过 I b32 b24 b16 b8
      break;
    case 8: // errorMsg
      hin.seek(8);
      hin.read_chunked_utf8_string(&error_msg);
      break;
    case 10: // errorStack
      hin.seek(10);
      hin.read_chunked_utf8_string(&error_stack);
      break;
    default:
      hin.seek(len);
      hin.skip_object();
    }
  }

  if (tag != 'z') {
    throw io_exception("fail to parse ConnectionResponse, expecting 'z'");
  }

  if (!error_msg.empty()) {
    ipacket->error_msg = new string(error_msg);
    if (!error_stack.empty()) {
      ipacket->error_msg->append("\nError Stack:\n");
      ipacket->error_msg->append(error_stack);
    }
  }
}

/*
 * hsf_request
 */
void hessian_encode_hsf_request(remoting_packet* opacket) {
  hsf_request* hsf_req = static_cast<hsf_request*>(opacket->request_obj);
  hessian_output hout(opacket->data);

  hout.add_ref();
  hout.print_8bit('M');
  hout.write_fast_type(CONST_C_STRING(HSF_REQUEST_CLASSNAME));

  hout.write_fast_string(CONST_C_STRING("targetServiceUniqueName"));
  hout.write_fast_string(*hsf_req->service_signature);
  hout.write_fast_string(CONST_C_STRING("methodName"));
  hout.write_fast_string(*hsf_req->method_name);

  List* args = hsf_req->args;
  hout.write_fast_string(CONST_C_STRING("methodArgSigs"));
  hout.add_ref();
  hout.print_8bit('V');
  hout.write_fast_type(CONST_C_STRING("[string"));
  if (args) {
    int argc = args->size();
    Object* arg;
    hout.write_length(argc);
    for (int i = 0; i < argc; i++) {
      hout.write_fast_string((arg = args->get(i)) ? arg->classname() : "null");
    }
  } else {
    hout.write_length(0);
  }
  hout.print_8bit('z');

  hout.print_8bit('z'); // end of hsf_requst

  // 序列化参数
  if (args) {
    int argc = args->size();
    for (int i = 0; i < argc; i++) {
      hout.write_object(args->get(i));
    }
  }
}

void hessian_decode_hsf_request(remoting_packet* ipacket) {
  hessian_input hin(
      ipacket->input + ipacket->conn_len + ipacket->app_classname_len,
      ipacket->app_len);
  hin.seek(4 + HSF_REQUEST_CLASSNAME_SIZE);

  hsf_request* req = new hsf_request();
  ipacket->request_obj = req;
  memset(req, 0, sizeof(hsf_request));

  hin.add_ref();

  int tag;
  vector<string> arg_classnames;
  while ((tag = hin.peek()) == 'S') {
    string key;
    hin.read_fast_string(&key);

    if (key == "methodName") {
      req->method_name = hin.read_chunked_utf8_string();
    } else if (key == "targetServiceUniqueName") {
      req->service_signature = hin.read_fast_string();
    } else if (key == "methodArgSigs") {
      // deal with "List"
      tag = hin.parse_8bit();
      if (tag == 'V') {
        hin.add_ref();
        hin.read_fast_type(); // skip type
        uint32_t arg_size = hin.read_length();
        if (arg_size != 0xFFFFFFFF) {
          arg_classnames.resize(arg_size);
        }
        for (uint32_t arg_index = 0; arg_index < arg_size; ++arg_index) {
          hin.read_fast_string(&(arg_classnames[arg_index]));
        }
        hin.seek(1); // skip 'z' for "[string" end

      } else if (tag != 'N') {
        throw io_exception(string(
          "fail to parse field 'methodArgSigs' of HSFResponse, encounter tag: ").append(1, tag));
      }
    } else {
      hin.skip_object();
    }
  }

  if (tag != 'z') {
    throw io_exception(string(
      "fail to parse field of HSFResponse, expecting 'z' but encounter tag: ").append(1, tag));
  }

  hin.seek(1);

  req->args_sig = new string();

  if (!arg_classnames.empty()) {
    uint32_t size = arg_classnames.size();
    req->args = new List();
    req->args->reserve(size);

    req->args_sig->append(arg_classnames[0]);
    pair<Object*, bool> ret0 = hin.read_object();
    req->args->push_back_ptr(ret0.first, ret0.second);

    for (size_t i = 1; i < arg_classnames.size(); ++i) {
      req->args_sig->append(1, ',').append(arg_classnames[i]);
      pair<Object*, bool> ret = hin.read_object();
      req->args->push_back_ptr(ret.first, ret.second);
    }
  }
}

/*
 * hsf_response
 */
void hessian_encode_hsf_response(remoting_packet* opacket) {
  hsf_response* hsf_resp = static_cast<hsf_response*>(opacket->response_obj);
  hessian_output hout(opacket->data);

  hout.add_ref();
  hout.print_8bit('M');
  hout.write_fast_type(CONST_C_STRING(HSF_RESPONSE_CLASSNAME));

  hout.write_fast_string(CONST_C_STRING("isError"));
  hout.write_bool(hsf_resp->is_error);

  hout.write_fast_string(CONST_C_STRING("errorMsg"));
  if (hsf_resp->error_msg) {
    hout.write_utf8_string(*hsf_resp->error_msg);
  } else {
    hout.write_null();
  }

  hout.write_fast_string(CONST_C_STRING("appResponse"));
  hout.write_object(hsf_resp->app_response);
  hout.print_8bit('z');
}

void hessian_decode_hsf_response(remoting_packet* ipacket) {
  hessian_input hin(
      ipacket->input + ipacket->conn_len + ipacket->app_classname_len,
      ipacket->app_len);
  hin.seek(4 + HSF_RESPONSE_CLASSNAME_SIZE);

  hsf_response* resp = new hsf_response();
  ipacket->response_obj = resp;
  memset(resp, 0, sizeof(hsf_response));
  hin.add_ref();

  int tag;
  while ((tag = hin.peek()) == 'S') {
    string key;
    hin.read_fast_string(&key);

    if (key == "isError") {
      resp->is_error = hin.read_bool();
    } else if (key == "errorMsg") {
      resp->error_msg = hin.read_chunked_utf8_string();
    } else if (key == "appResponse") {
      resp->app_response = hin.read_object().first;
    } else {
      hin.skip_object();
    }
  }
  if (tag != 'z') {
    throw io_exception(string(
      "fail to parse field of class 'com.taobao.hsf.domain.HSFResponse', "
      "expecting key tag 'S' but actually met: ").append(1, tag));
  }
  hin.seek(1); // skip 'z' for end
}

/*
 * connection_heart_beat
 */
void hessian_encode_connection_heart_beat(remoting_packet* opacket) {
  string* url = static_cast<string*>(opacket->user_data);
  hessian_output hout(opacket->data);

  hout.add_ref();
  hout.print_8bit('M');
  hout.write_fast_type(CONST_C_STRING(CONNECTION_HEART_BEAT_CLASSNAME));

  hout.write_fast_string(CONST_C_STRING("clientUrl"));
  if (url) {
    hout.write_fast_string(*url);
  } else {
    hout.write_null();
  }
  hout.print_8bit('z');
}

void hessian_decode_connection_heart_beat(remoting_packet* ipacket) {
  hessian_input hin(
      ipacket->input + ipacket->conn_len + ipacket->app_classname_len,
      ipacket->app_len);
  hin.seek(4 + CONNECTION_HEART_BEAT_CLASSNAME_SIZE);

  hin.add_ref();

  int tag, len;
  while ((tag = hin.parse_8bit()) == 'S') {
    switch (len = hin.parse_16bit()) { // read field name's length
    case 9: // clientUrl
      hin.seek(9);
      ipacket->user_data = hin.read_chunked_utf8_string();
      return;
    default:
      hin.seek(len);
      hin.skip_object();
    }
  }

  if (tag != 'z') {
    throw io_exception("fail to parse ConnectionHeartBeat, expecting 'z'");
  }
}

}

