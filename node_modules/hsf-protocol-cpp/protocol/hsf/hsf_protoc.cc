#include "tb_remoting.h"  // tb-remoting 网络层
#include "hsf_protoc.h"
#include "hsf_define.h"
// Hessian 序列化相关
#include "hessian_protoc.h"
#include "hessian_input.h"
#include "hessian_output.h"

/*
 * HSF 协议对象的封装、解析
 * @author jifeng
 */
namespace hsf {

using namespace std;

static remoting_handler_t client_hessian_handler = {0};
static remoting_handler_t server_hessian_handler = {0};
static remoting_handler_t heartbeat_hessian_handler = {0};

void hsf_request_encode(const hsf_request_object& input, string& output) {
  hsf_request hsf_req;
  hsf_req.service_signature = input.service_signature;
  hsf_req.method_name = input.method_name;
  hsf_req.args = input.method_args;

  remoting_packet opacket = {0};
  opacket.request_obj = &hsf_req;
  opacket.data = &output;
  opacket.packet_type = REMOTING_PACKET_TYPE_CLIENT;
  opacket.packet_id = input.packet_id;
  opacket.protocol = input.protocol;

  remoting_handler_encode(&client_hessian_handler, &opacket);
}

void hsf_request_heartbeat_encode(uint64_t packet_id, std::string& output) {
  remoting_packet opacket = {0};
  opacket.packet_id = packet_id;
  opacket.protocol = REMOTING_PROTOCOL_HESSIAN;
  opacket.async = true;
  opacket.user_data = NULL;
  opacket.packet_type = REMOTING_PACKET_TYPE_CLIENT;
  opacket.data = &output;

  remoting_handler_encode(&heartbeat_hessian_handler, &opacket);
}

void hsf_response_encode(const hsf_response_object& input, std::string& output) {
  hsf_response hsf_resp;
  hsf_resp.is_error = input.error_msg ? 1 : 0;
  hsf_resp.error_msg = input.error_msg;
  hsf_resp.app_response = input.method_ret;

  remoting_packet opacket = {0};
  opacket.response_obj = &hsf_resp;
  opacket.data = &output;
  opacket.packet_type = REMOTING_PACKET_TYPE_SERVER;
  opacket.packet_id = input.packet_id;
  opacket.protocol = input.protocol;
  remoting_handler_encode(&server_hessian_handler, &opacket);
}

const char* remoting_packet_decode(const char* input, uint32_t size, remoting_packet& ipacket) {
  if (size <= 14) {
    return NULL;
  }

  // 不符合协议的非法包
  uint8_t version = *((unsigned char *) input);
  uint8_t header_type = *((unsigned char *) input + 1);
  if (unlikely(version != 0xD || !(header_type == 0x0 || header_type == 0x1))) {
    return NULL;
  }

  // 通讯对象的长度
  uint32_t conn_len = bswap_32(*((uint32_t *)(input + 5)));
  // 应用对象类名的长度
  uint32_t app_classname_len = (uint32_t) *(((unsigned char *) input + 9));
  // 应用对象的长度
  uint32_t app_len = bswap_32(*((uint32_t *)(input + 10)));

  // 响应包的总长度
  uint32_t packet_size = 14 + conn_len + app_classname_len + app_len;

  if (unlikely(packet_size > 5 * 1024 * 1024)) {
    return NULL;
  }

  if (size < packet_size) {
    return NULL;
  }

  ipacket.input = input + 14;
  ipacket.conn_len = conn_len;
  ipacket.app_classname_len = app_classname_len;
  ipacket.app_len = app_len;

  ipacket.packet_type = header_type;
  ipacket.protocol = *((unsigned char *) input + 2);
  return input + packet_size;
}

const char* hsf_request_decode(const char* input, uint32_t size, hsf_request_object& output) {
  remoting_packet ipacket = {0};
  const char* ret = remoting_packet_decode(input, size, ipacket);
  if (ret > input) {
    remoting_handler_decode_conn(&server_hessian_handler, &ipacket);
    output.type = HEARTBEAT;
    output.protocol = (protocol_type) ipacket.protocol;
    output.packet_id = ipacket.packet_id;

    if (ipacket.error_msg) {
      return NULL;
    }
    remoting_handler_decode_app(&server_hessian_handler, &ipacket);
    hsf_request* hsf_req = (hsf_request*) ipacket.request_obj;
    if (hsf_req) {
      output.type = HSF;
      output.service_signature = hsf_req->service_signature;
      output.method_name = hsf_req->method_name;
      output.method_args = hsf_req->args;
      delete hsf_req->args_sig;
      delete hsf_req;
    }
  }
  return ret;
}

const char* hsf_response_decode(const char* input, uint32_t size, hsf_response_object& output) {
  remoting_packet ipacket = {0};
  const char* ret = remoting_packet_decode(input, size, ipacket);
  if (ret > input) {
    remoting_handler_decode_conn(&client_hessian_handler, &ipacket);
    output.type = HEARTBEAT;
    output.protocol = (protocol_type) ipacket.protocol;
    output.packet_id = ipacket.packet_id;
    output.error_msg = ipacket.error_msg;

    if (ipacket.error_msg) {
      return NULL;
    }

    remoting_handler_decode_app(&client_hessian_handler, &ipacket);

    output.error_msg = ipacket.error_msg;
    hsf_response* hsf_resp = (hsf_response*) ipacket.response_obj;
    if (hsf_resp) {
      output.type = HSF;
      output.method_ret = hsf_resp->app_response;
      if (output.error_msg) {
        output.error_msg->append(*hsf_resp->error_msg);
        delete hsf_resp->error_msg;
      } else {
        output.error_msg = hsf_resp->error_msg;
      }
      delete hsf_resp;
    }
  }
  return ret;
}

static struct hsf_protoc_initializer {
  hsf_protoc_initializer() {
    client_hessian_handler.encode_conn = hessian_encode_connection_request;
    client_hessian_handler.encode_app = hessian_encode_hsf_request;
    client_hessian_handler.encode_heartbeat = hessian_encode_connection_heart_beat;
    client_hessian_handler.decode_conn = hessian_decode_connection_response;
    client_hessian_handler.decode_app = hessian_decode_hsf_response;
    client_hessian_handler.decode_heartbeat = remoting_handler_noop;
    client_hessian_handler.encode_app_classname = HSF_REQUEST_CLASSNAME;
    client_hessian_handler.encode_app_classname_len = HSF_REQUEST_CLASSNAME_SIZE;
    client_hessian_handler.decode_app_classname = HSF_RESPONSE_CLASSNAME;
    client_hessian_handler.decode_app_classname_len = HSF_RESPONSE_CLASSNAME_SIZE;



    server_hessian_handler.encode_conn = hessian_encode_connection_response;
    server_hessian_handler.encode_app = hessian_encode_hsf_response;
    server_hessian_handler.encode_heartbeat = NULL;
    server_hessian_handler.decode_conn = hessian_decode_connection_request;
    server_hessian_handler.decode_app = hessian_decode_hsf_request;
    server_hessian_handler.decode_heartbeat = remoting_handler_noop;
    server_hessian_handler.encode_app_classname = HSF_RESPONSE_CLASSNAME;
    server_hessian_handler.encode_app_classname_len = HSF_RESPONSE_CLASSNAME_SIZE;
    server_hessian_handler.decode_app_classname = HSF_REQUEST_CLASSNAME;
    server_hessian_handler.decode_app_classname_len = HSF_REQUEST_CLASSNAME_SIZE;

    heartbeat_hessian_handler.encode_conn = hessian_encode_connection_request;
    heartbeat_hessian_handler.encode_app = hessian_encode_connection_heart_beat;
    heartbeat_hessian_handler.encode_heartbeat = hessian_encode_connection_heart_beat;
    heartbeat_hessian_handler.encode_app_classname = CONNECTION_HEART_BEAT_CLASSNAME;
    heartbeat_hessian_handler.encode_app_classname_len = CONNECTION_HEART_BEAT_CLASSNAME_SIZE;
  }
} hsf_protoc_init;

}
