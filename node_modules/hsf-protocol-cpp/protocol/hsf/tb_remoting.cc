#include "hessian_protoc.h"
#include "tb_remoting.h"
#include "hsf_define.h"
#if defined(__linux__) || defined(__GLIBC__) || defined(__GNU__)
#include <byteswap.h>
#else
 #define bswap_16(value)  \
   ((((value) & 0xff) << 8) | ((value) >> 8))

 #define bswap_32(value) \
   (((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
   (uint32_t)bswap_16((uint16_t)((value) >> 16)))

 #define bswap_64(value) \
   (((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
       << 32) | \
   (uint64_t)bswap_32((uint32_t)((value) >> 32)))
#endif
#include <netinet/in.h>
#include <string>
/*
 * tb-remoting 网络通讯实现
 * @author jifeng
 */
namespace hsf {

using namespace std;

///////////////////////////////////////////////////////////////////////////////
// 序列化/反序列化回调
///////////////////////////////////////////////////////////////////////////////
static inline void write_32bit_at(
    string& str,
    uint32_t pos,
    uint32_t value) {
  str[  pos] = (char) (value >> 24);
  str[++pos] = (char) (value >> 16);
  str[++pos] = (char) (value >> 8);
  str[++pos] = (char) value;
}

/**
 * 序列化 tb-remoting 请求
 */
void remoting_handler_encode(
    remoting_handler_t* rh,
    remoting_packet* opacket) {
  string* data;
  if (opacket->data == NULL) {
    // TODO 不由这里直接申请内存
    data = new string();
    opacket->data = data;
    data->reserve(1024);
  } else {
    data = opacket->data;
  }

  // 写协议头
  data->push_back((char) 0xd); // PROTOCOL_VERSION
  data->push_back((char) opacket->packet_type); // REQUEST=0/RESPONSE=1
  data->push_back((char) opacket->protocol); // PROTOCOL HESSIAN=1
  data->push_back((char)
      opacket->packet_type == REMOTING_PACKET_TYPE_CLIENT ? 0x2 : 0x0); // DIRECTION
  data->append(10, '\0');

  // 写 conn_request
  uint32_t cstart = data->size();
  rh->encode_conn(opacket);
  write_32bit_at(*data, cstart - 9, (opacket->conn_len = data->size() - cstart));
  // 写 app_classname
  data->append(rh->encode_app_classname, rh->encode_app_classname_len);
  (*data)[cstart - 5] = (char) (opacket->app_classname_len = rh->encode_app_classname_len);

  // 写 app_object
  uint32_t astart = data->size();
  rh->encode_app(opacket);
  write_32bit_at(*data, cstart - 4, (opacket->app_len = data->size() - astart));
}

/**
 * 反序列化 tb-remoting 的网络层部分
 */
void remoting_handler_decode_conn(
    remoting_handler_t* rh,
    remoting_packet* ipacket) {
  try {
    rh->decode_conn(ipacket);
  } catch (const exception& ex) {
    ipacket->error_msg = new string("fail to decode connection object: ");
    ipacket->error_msg->append(ex.what());
  }
}

/**
 * 反序列化 tb-remoting 的应用层部分
 */
void remoting_handler_decode_app(
    remoting_handler_t* rh,
    remoting_packet* ipacket) {
  const char* app_classname_pos = ipacket->input + ipacket->conn_len;
  try {
    if (likely(memcmp(app_classname_pos, rh->decode_app_classname, rh->decode_app_classname_len) == 0)) {
      rh->decode_app(ipacket);
    } else if (memcmp(app_classname_pos, CONST_C_STRING("java.lang.Byte")) == 0) {
      ; // 收到一个 Byte 的心跳响应，忽略
    } else if (memcmp(app_classname_pos, CONST_C_STRING(CONNECTION_HEART_BEAT_CLASSNAME)) == 0) {
      rh->decode_heartbeat(ipacket); // 心跳请求
    } else {
      ipacket->error_msg = new string(
          "the app object is invalid, expecting ");
      ipacket->error_msg->append(rh->decode_app_classname, rh->decode_app_classname_len);
    }
  } catch (const exception& ex) {
    ipacket->error_msg = new string("fail to decode app object: ");
    ipacket->error_msg->append(ex.what());
  }
}

void remoting_handler_noop(remoting_packet* packet) {
}
}
