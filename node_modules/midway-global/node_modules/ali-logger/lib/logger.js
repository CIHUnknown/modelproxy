/**!
 * logger - lib/logger.js
 *
 * Copyright(c) 2012 - 2014 Alibaba Group Holding Limited.
 *
 * Authors:
 *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)
 */

"use strict";

/**
 * Module dependencies.
 */

var tty = require('tty');
var utility = require('utility');
var address = require('address');
var ms = require('ms');
var fs = require('fs');
var path = require('path');
var util = require('util');
var logfilestream = require('logfilestream');
var os = require('os');
var EventEmitter = require('events').EventEmitter;
var urllib = require('urllib');

var supportColor = tty.isatty(1) || process.env.DEBUG_COLORS;

var logger = new EventEmitter();

module.exports = logger;

logger._streams = [];
logger.enable = true; // you can disable it on running.
logger.enableAccesslog = false;

logger.ALL = -10000;
logger.DEBUG = -1;
logger.LOG = 0;
logger.INFO = 0;
logger.WARN = 1;
logger.ERROR = 2;
logger.TRACE = 3;
logger._level = logger.INFO;
logger._stdoutLevel = 10000; // default is never to stdout

logger.methods = [
  { name: 'debug', level: logger.DEBUG, color: 0 },
  { name: 'info', level: logger.INFO, color: 6 }, // log as info by default
  { name: 'warn', level: logger.WARN, color: 3, },
  { name: 'error', level: logger.ERROR, color: 1 },
];

logger.addMethods = function (methods) {
  if (!Array.isArray(methods)) {
    methods = [methods];
  }
  methods.forEach(function (m) {
    var name = m;
    var level = logger.TRACE;
    if (typeof m !== 'string') {
      name = m.name;
      level = m.level || logger.TRACE;
    }

    logger.methods.push({
      name: name,
      level: level
    });
  });
};

logger.setLevel = function (level) {
  if (typeof level === 'number') {
    logger._level = level;
  }
};

logger.setStdoutLevel = function (level) {
  if (typeof level === 'number') {
    logger._stdoutLevel = level;
  }
};

logger.end = function () {
  this._streams.forEach(function (s) {
    s.end();
  });
};

var createStream = function (opts, name) {
  var streamOptions = {
    logdir: opts.logdir,
    duration: opts.duration,
    // using momentjs date format: http://momentjs.com/docs/#/displaying/format/
    nameformat: opts.nameformat.replace('{{level}}', name)
  };
  var stream = logfilestream(streamOptions);
  stream.on('error', function (err) {
    // if disk error, only can do is show error log to stderr.
    console.error('[%s] [%s] %s', Date(), process.pid, err.stack || err);
  });
  logger._streams.push(stream);
  return stream;
};

logger.init = function init(options) {
  var ONE_DAY = ms('1d');

  options.logdir = options.logdir;
  if (!fs.existsSync(options.logdir)) {
    fs.mkdirSync(options.logdir);
  }
  options.duration = options.duration || ONE_DAY;
  options.nameformat = '[{{level}}.]YYYY-MM-DD[.log]';
  var isDevelopment = process.env.NODE_ENV === 'debug' || process.env.NODE_ENV === 'development';
  if (typeof options.level !== 'number') {
    options.level = logger.INFO;
    if (isDevelopment) {
      options.level = logger.DEBUG;
    }
  }
  if (typeof options.stdoutLevel !== 'number') {
    if (isDevelopment) {
      options.stdoutLevel = logger.DEBUG;
    }
  }
  logger.setLevel(options.level);
  logger.setStdoutLevel(options.stdoutLevel);

  if (options.methods) {
    logger.addMethods(options.methods);
  }

  if (options.accessLog) {
    options.accessLogDuration = options.accessLogDuration || options.duration;
    options.accessLogNameformat = options.accessLogNameformat || options.nameformat;
    logger._accessLogStream = createStream({
      logdir: options.logdir,
      duration: options.accessLogDuration,
      nameformat: options.accessLogNameformat,
    }, 'access');
    logger.enableAccesslog = true;
  }

  var oplog = options.oplogOptions;
  if (oplog) {
    logger._initOplog(oplog.systemId, oplog.systemName, oplog.url, oplog.options);
    logger._oplogStream = createStream(options, 'oplog');
  }

  var hasLogMethod = false;

  logger.methods.forEach(function (catetory) {
    if (catetory.name === 'log') {
      hasLogMethod = true;
    }

    var stream = createStream(options, catetory.name);
    function write(msg) {
      if (!logger.enable || !msg || logger._level > catetory.level) {
        return;
      }

      // var date = moment();
      // var time = date.format('YYYY-MM-DD HH:mm:ss.SSS');
      var time = utility.logDate();
      if (msg instanceof Error) {
        if (options.stderr && msg.message.indexOf('mock') < 0) {
          console.error(msg.stack);
        }
        var err = {
          name: msg.name,
          message: msg.message,
          url: msg.url || '',
          data: msg.data || '',
          pid: process.pid,
        };
        if (msg.code !== undefined) {
          err.code = msg.code;
        }
        if (err.name === 'Error' && typeof err.code === 'string') {
          err.name = err.code + err.name;
        }
        if (msg.host) {
          err.host = msg.host;
          err.message += ' (' + err.host + ')';
        }
        err.domainThrown = !!(msg.domain_thrown || msg.domainThrown);
        err.stack = msg.stack || 'no_stack';
        err.name = err.name + 'Exception';
        err.time = time;
        err.hostname = os.hostname();
        // name and stack could not be change on node 0.11+
        var errName = msg.name;
        var errStack = err.stack;
        errStack = errName + ': ' + err.message + '\n' + errStack.substring(errStack.indexOf('\n') + 1);
        msg = util.format('%s nodejs.%s: %s\npid: %s\ndomainThrown: %s\nHost: %s\nURL: %s\nData: %j\n%s\n\n',
          time,
          err.name,
          errStack,
          err.pid,
          err.domainThrown,
          err.hostname,
          err.url,
          err.data,
          time
        );
        logger.emit('logerror', err, msg);
      } else {
        // normal log: `YYYY-MM-DD HH:mm:ss.SSS [PID] message string...`
        msg = time + ' [' + process.pid + '] ' + util.format.apply(util, arguments) + '\n';
      }
      if (msg) {
        stream.write(msg);
        if (logger._stdoutLevel <= catetory.level) {
          msg = '[' + catetory.name + '] ' + msg;
          if (supportColor) {
            msg = '\u001b[9' + catetory.color + 'm' + msg + '\u001b[0m';
          }
          process.stdout.write(msg);
        }
      }
    }

    logger[catetory.name] = write;
  });

  // if not log method, link info to log
  if (!hasLogMethod) {
    logger.log = logger.info;
  }
};

logger.ACCESS_LOG_FORMAT = /^[\w\.\-]+ \d+ [\d\-]+ \[\d{2}\/\w{3}\/\d{4}\:\d{2}\:\d{2}\:\d{2} [\+\-]\d{4}\] \"\w{3,8} [^\"]+\" \d+ [\d\-]+ \"[^\"]+\" \"[^\"]+\"$/;
logger.ACCESS_LOG_EXTRA_FORMAT = /^[\w\.\-]+ \d+ [\d\-]+ \[\d{2}\/\w{3}\/\d{4}\:\d{2}\:\d{2}\:\d{2} [\+\-]\d{4}\] \"\w{3,8} [^\"]+\" \d+ [\d\-]+ \"[^\"]+\" \"[^\"]+\" \d+ \d+$/;

logger.accessLog = function (ip, usec, method, url, status, bytes, referer, userAgent) {
  if (!this.enable || !this.enableAccesslog) {
    return;
  }

  bytes = bytes || '-';
  referer = referer || '-';
  userAgent = userAgent || '-';

  // format: {ip} {usec} {pid} [{logdate}] "{method} {url}" {status} {bytes} "{referer}" "{userAgent}"
  var log = ip + ' ' + usec + ' ' + process.pid +
    ' [' + utility.accessLogDate() + '] "' +
    method + ' ' + url + '" ' + status + ' ' + bytes + ' "' + referer + '" "' + userAgent + '"\n';

  // util.format: log.accessLog() x 49,913 ops/sec ±5.14% (80 runs sampled)
  // string plus: log.accessLog() x 87,713 ops/sec ±7.32% (73 runs sampled)
  log && this._accessLogStream.write(log);
};

logger.accessLogExtra = function (ip, usec, method, url, status, bytes, referer, userAgent, hitCache, backendTime) {
  if (!this.enable || !this.enableAccesslog) {
    return;
  }

  bytes = bytes || '-';
  referer = referer || '-';
  userAgent = userAgent || '-';

  // format: {ip} {usec} {pid} [{logdate}] "{method} {url}" {status} {bytes} "{referer}" "{userAgent}" {hitcache} {backendtime}
  var log = ip + ' ' + usec + ' ' + process.pid +
    ' [' + utility.accessLogDate() + '] "' +
    method + ' ' + url + '" ' + status + ' ' + bytes + ' "' + referer + '" "' + userAgent + '" ' +
    hitCache + ' ' + backendTime + '\n';

  // util.format: log.accessLog() x 49,913 ops/sec ±5.14% (80 runs sampled)
  // string plus: log.accessLog() x 87,713 ops/sec ±7.32% (73 runs sampled)
  log && this._accessLogStream.write(log);
};

/**
 * connect access log middleware
 *
 * @param {Object} options
 *  - {Object} [timer] impl `now()`, default is `Date`
 *  - {String} [method] access log method, default is 'accessLog',
 *      you can set 'accessLogExtra' if you want to log backend time
 *  - {Array} [resHeaders] append res headers to request url, default is empty
 * @return {Function(req, res, next)}
 */
logger.accessLogMiddleware = function (options) {
  options = options || {};
  var timer = options.timer || Date;
  var method = options.method || 'accessLog';
  var resHeaders = options.resHeaders || [];
  return function (req, res, next) {
    var start = timer.now();
    var end = res.end;
    res.accessLogBackendTime = 0;
    res.accessLogHitCache = 0;
    var ip = req.ip;
    if (!ip) {
      ip = req.connection && req.connection.remoteAddress;
      if (!ip) {
        var sock = req.socket;
        if (sock.socket) {
          ip = sock.socket.remoteAddress;
        } else {
          ip = sock.remoteAddress || '-';
        }
      }
    }

    res.end = function (chunk, encoding) {
      res.end = end;
      res.end(chunk, encoding);

      if (!logger.enableAccesslog) {
        return;
      }

      var usec = timer.now() - start;
      var bytes = parseInt(res.getHeader('Content-Length'), 10);
      var url = req.originalUrl || req.url;
      if (resHeaders.length) {
        if (url.indexOf('?') < 0) {
          url += '?';
        }
        for (var i = 0; i < resHeaders.length; i++) {
          var h = resHeaders[i];
          var v = res.getHeader(h);
          if (v) {
            url += '&' + h + '=' + v;
          }
        }
      }
      logger[method](ip, usec, req.method, url, res.statusCode,
        bytes,
        req.headers.referer || req.headers.referrer,
        req.headers['user-agent'],
        res.accessLogHitCache, res.accessLogBackendTime);
    };
    next();
  };
};

var oplogOptions = logger.oplogOptions = {
  systemId: null,
  systemName: null,
  ip: '0.0.0.0',
  mac: '00:00:00:00:00:00',
  defaultLevel: 'NORMAL',
};

/**
 * 初始化oplog 基本信息
 * @param {String} systemId 系统ID, 系统ID=集团接入编号ID_下发系统ID
 * @param {String} systemName 系统中文名称, 产品名称
 * @param {String} [url] 通过http方式请求的时候的地址
 * @param {Object} [options], 其他配置参数
 *  - {String} defaultLevel, 默认 'NORMAL'
 */
logger._initOplog = function (systemId, systemName, url, options) {
  if (options) {
    for (var k in options) {
      oplogOptions[k] = options[k];
    }
  }
  oplogOptions.systemId = systemId;
  oplogOptions.systemName = systemName;
  oplogOptions.url = url;

  address.mac(function (err, mac) {
    if (err) {
      console.error('[%s] [%s] get mac address error: %s', Date(), process.pid, err.stack);
    }
    if (mac) {
      oplogOptions.mac = mac;
    }
    console.log('[%s] [%s] get mac address: %j', Date(), process.pid, mac);
  });

  oplogOptions.ip = address.ip();
  console.log('[%s] [%s] get ip: %j', Date(), process.pid, oplogOptions.ip);
};

var OPLOG_SEP = logger.OPLOG_SEP = '\u0001';
var OPLOG_KV_SEP = '\u0002';
var OPLOG_ARRAY_SEP = '\u0003';

/**
 * 记录系统后台操作日志
 *
 * @param {Object} user 用户信息
 *  - {String} uid 用户id, buc id, taobao user id 等
 *  - {String} nick 用户昵称
 *  - {String} [realname] 用户真名，没有则默认为 nick
 *  - {String} clientId 客户端标识, 浏览器UA, IP等
 * @param {Object} op 操作日志参数
 *  - {String} traceId 操作关联ID, 跟踪id, 操作链, 用于跟踪操作影响
 *  - {String} targetType 目标类别, 见 目标类别表
 *  - {String} customerId 客户ID, 操作目标的所有者，如某个卖家的商品.客户id就是卖家用户id
 *  - {String} name 操作名称, 英文+中文 如 "deleteCategory 删除类目","createLog 创建日志" 等动词
 *  - {String} [level] 操作级别, 具体由业务方界定, 默认是 `oplogOptions.defaultLevel`. 'NORMAL', 'WARNNING', 'ERROR'
 *  - {String} item 操作对象名称, 例如 类目 类目属性的名称
 *  - {String} itemId 操作对象ID, 类目名称id 属性名称id等
 *  - {String|Object} content 操作内容, key分隔符oldvalue分隔符newvalue
 *    如 {name: ['旧值', '新值'], ...}
 *  - {String} desc 操作描述, 操作的补充说明
 */
logger.oplog = function (user, op) {
  this._oplogStream.write(this.getOplogMsg(user, op));
};

logger.oplogByHttp = function (user, op, callback) {
  if (!oplogOptions.url) {
    throw new TypeError('Must `initOplog` with url');
  }
  urllib.request(oplogOptions.url, {
    method: 'POST',
    content: new Buffer(this.getOplogMsg(user, op))
  }, function (err, data, res) {
    callback && callback(err, data, res);
  });
};

logger.getOplogMsg = function (user, op) {
  if (!oplogOptions.systemId) {
    throw new TypeError('Must `initOplog()` first');
  }

  user.realname = user.realname || user.nick;
  op.level = op.level || oplogOptions.defaultLevel;
  var content = op.content;
  if (typeof content === 'object') {
    var kvContents = [];
    for (var k in content) {
      var kvContent = k + OPLOG_KV_SEP;
      var item = content[k];
      if (Array.isArray(item)) {
        kvContent += item.join(OPLOG_KV_SEP);
      } else {
        kvContent += item;
      }
      kvContents.push(kvContent);
    }
    op.content = kvContents.join(OPLOG_ARRAY_SEP);
  }

  var msg = oplogOptions.systemId + OPLOG_SEP + // 系统ID
    oplogOptions.systemName + OPLOG_SEP +       // 系统名称
    oplogOptions.ip + OPLOG_SEP +               // 服务端ip
    oplogOptions.mac + OPLOG_SEP +              // 服务器mac
    user.uid + OPLOG_SEP +                      // 操作人ID
    user.nick + OPLOG_SEP +                     // 操作人花名
    user.realname + OPLOG_SEP +                 // 操作人真名
    user.clientId + OPLOG_SEP +                 // 客户端标识 设备指纹
    op.traceId + OPLOG_SEP +                    // 操作关联ID
    op.targetType + OPLOG_SEP +                 // 目标类别
    op.customerId + OPLOG_SEP +                 // 客户ID
    op.name + OPLOG_SEP +                       // 操作名称
    op.level + OPLOG_SEP +                      // 操作类别
    utility.logDate() + OPLOG_SEP +             // 操作时间 2012-05-12 14:20:11.578精确到毫秒
    op.item + OPLOG_SEP +                       // 操作对象名称
    op.itemId + OPLOG_SEP +                     // 操作对象ID
    op.content + OPLOG_SEP +                    // 操作内容
    op.desc + '\n';                                    // 操作描述

  return msg;
};
