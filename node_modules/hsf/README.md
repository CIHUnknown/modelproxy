## node-hsf [![status](http://toast.corp.taobao.com/task/state/id/1287)](http://toast.corp.taobao.com/task/view/id/1287)

淘宝 hsf 的 node 版本，实现了 provider 和 consumer 的主要功能。序列化反序列化模块通过 C++ 模块实现,网络传输部分 node 实现。

同时在 hsf 的基础上扩展了 node 之间互相调用的 JSON 序列化方式，性能有极大提升。

* benchmark: [benchmark](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/benchmark.md)
* changelog: [changelog](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/changelog.md)

## node-hsf v1.0

node-hsf 升级到 1.0，用纯 js 重写了整个 hsf 协议的序列化方式，不再需要编译 c++ addon, 完全支持所有的平台。

 * 纯 js 实现导致 node-hsf 性能降低严重，将会在之后的版本中修复，如果有高性能的服务，可以通过在外部安装 `hsf-protocol-cpp` 模块，引入 c++ addon 的 hsf 序列化包。 node-hsf 将会引用 c++ addon 序列化。
 * js 版本的协议支持传递循环引用对象，其他地方也可能会和 c++ 版本的协议稍微有出入，如果要在生产环境使用 c++ addon，而开发环境使用 js 协议，需要进行一定的测试。
 * 提供一个辅助编写 hsf 调用的参数的库: [js-to-java](https://github.com/node-modules/js-to-java)，具体的使用案例可以查看[这里](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/test/invoke_java_test.js)。

使用遇到任何问题，旺旺联系@不四。

## Main Feature

### HSF Feature

* Hessian 序列化
* 消费者异步调用
* 消费者调用超时设置（服务级别/方法级别）
* 消费者路由轮询
* 服务者服务发布
* 服务者流量限制功能

### Customize for Node

* node 互相调用使用 JSON 序列化，性能比 http 高 **70%** 。benchmark: [benchmark](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/benchmark.md)
* 服务中间件
* client 根据服务注册信息自动选择序列化类型
* server 通过调用信息决定序列化类型，兼容 node 与 java 用不同序列化方式调用

## HSF介绍及相关文档

HSF 全称为 High-Speed Service Framework，旨在为淘宝的应用提供一个分布式的服务框架。

### 原理

 1. HSF 服务端向 configServer 注册信息，提供服务的地址和端口号（可以多个），同时监听该端口等待客户端调用。
 2. HSF 客户端定时向 configServer 请求指定 `服务名+版本号` 的服务端地址和端口号。
 3. 客户端和服务端直接建立连接，通过 HSF 指定的序列化, 反序列化方法和传输协议进行 TCP 通讯。

### 关于 configServer host 的配置值：

* 日常: 10.232.16.8
* 线上: commonconfig.config-host.taobao.com
* 预发: 172.23.226.84

### 相关文档

 * [HSF 项目说明](http://confluence.taobao.ali.com/pages/viewpage.action?pageId=819280)
 * [HSF 查询服务](http://hsf.taobao.net/hsfops/)

## 安装

通过内部 npm 安装：

```bash
$ npm install tnpm -g
$ tnpm install hsf
```

## node 发布 HSF 服务

```js
var hsf = require('hsf');

/**
 * HSFServer
 * @param {Object} options
 *  - {String} configSvr, default is 'commonconfig.taobao.net'.config server的地址，根据各个环境不同地址不同
 *  - {String|Array} serviceName, default is 'com.taobao.hsfcpp.service.nodejs.demo'. 注册的服务名字
 *  - {String|Array} version, defailt is '1.0.0' 注册服务的版本
 *  - {String} group, default is 'HSF'  设置服务的分组
 *  - {Number} port, default is `12200` 监听的端口
 *  - {String|WriteStream|function} logger, log file path or log writable stream or log function.
      日志文件路径或者stream或者记录日志的方法
 *  - {Boolean} logOff, 关闭日志, default false
 *  - {Object} forwards, forwards info  可以将hsf流量copy一份转发给其他服务用于测试
 *    - {String} to, which server address want to forwards to. example: '127.0.0.1.12201'
 *    - {Object} options
 *      - reconnectTime default 5s
 *      - delay  default 10ms
 *  - {Boolean} autoCheck, default is `false`. 如果设置为true，则会开启服务的自检，
      会定时检查当前机器是否注册成功，每一个方法是否能够调用到
 *  - {Boolean} nohsf, default true. not only hsf， nodejs互相调用时将不使用hessian作为序列化方式。
      不支持buffer/date，性能上有提升
 *  - {Number} timeout, regist timeout to nitify java client，注册服务的超时时间到 config server ,
      告知 java 客户端超过多少毫秒后超时返回
 *  - {String} diamondHost, if you want to push api meta info to hsf, you need to set this.
 *      daily: "commonconfig.taobao.net"
 *      pre | online: "commonconfig.config-host.taobao.com"
 * @constructor
 */
var server = hsf.createServer({
  serviceName : 'com.taobao.hsfcpp.service.nodejs',
  version : '1.0.0',
  port : 12201,
  diamondHost: 'commonconfig.taobao.net'
});

// 注册一个HSF服务API,添加流量限制（方法级别和全局的接口级别。）
// 注意第一个参数是res，包含与客户端的连接信息以及发回响应的接口send()
function plus(res, a, b) {
  console.log('客户端地址和端口：%s:%d', res.socket.remoteAddress, res.socket.remotePort);
  console.log(a + b);
  res.send("sync function in nodejs return " + (a + b));
}

function time(res, a, b) {
  console.log(a * b);
  setTimeout(function () {
    res.send("sync function in nodejs return " + (a * b));
  }, 100);
}

var hsfFuncs = {
  hsfFunc1: function (res, a, b) {
    res.send('hsf func 1');
  },
  hsfFunc2: function (res, a, b) {
    res.send('hsf func 2');
  },
  httpFunc: function (res, a, b) {
    res.send('http func');
  },
  notFunc: 'string'
};

server.registFunc('plus', plus)
  .setLimiter('plus', 1000, 5000);    //流量限制1000， 峰值5000
  .registFunc('time', time)
  .registFunc(hsfFuncs, /^hsf/)       //将hsfFuncs对象内的所有符合条件的，且value为function的元素注册到hsf
  .setGlobalLimiter(2000, 5000);      //全局流量限制

// [可选] api meta 信息
var apiMeta = {
  codeSource: 'nodejs-demo-1.0.0-SNAPSHOT.jar',
  methods: [
    {
      name: 'ping2',
      parameterTypes: [],
      returnType: 'java.lang.String'
    },
    {
      name: 'plus',
      parameterTypes: [
        'java.lang.Long',
        'java.lang.Long'
      ],
      returnType: 'long'
    }
  ]
};

// 发布服务到 configServer
server.publish(apiMeta);
// 开始监听指定端口
server.listen();
```

HSFServer会有许多事件抛出：

```js
// 当configServer挂掉，无法注册的时候，会抛出ConfigServerError事件
server.on('configServerError', function (err) {
  // do something
});

// 当连接到configServer，注册服务成功的时候触发
server.on('CSconnect', function () {
  // do something
})

// 当与configServer的连接断开，服务不再注册的时候触发
server.on('CSdisconnect', function () {
  // do something
})

// 当hsf与客户端每次建立链接的时候触发
server.on('connection', function () {
  // do something
})

// 如果开启了autoCheck,则在自检发现问题的时候会触发,通过监听这个事件，可以知道提供服务的健康情况
server.on('autocheck', function (msg) {
  // do something
})
```

如果设置了 api meta 信息, 则能查看到: [com.taobao.hsfcpp.service.nodejs.benchmark:1.0.0](http://ops.jm.taobao.net/service-manager/service_search/search.htm?key=com.taobao.hsfcpp.service.nodejs.benchmark%3A1.0.0&type=1)

![1](http://nfs.nodeblog.org/9/7/970d7ccae05876eb9eb115ff3c071a43.png)

### HSF中间件

HSF server 提供类似 `connect` 的中间件支持。

```js
// 中间件形式类似于connect
// res.next()继续执行， res.send()返回结果
var middlewares = {
  ip: function (res) {
    if (res.remoteAddress !== '127.0.0.1') {
      res.send('address error');
    }
    res.next();
  },
  auth: function (res, name) {
    if (name !== 'busi') {
      res.send('403');
    }
    res.next();
  },
  add: function (res) {
    res._type = 'debug';
    res.next();
  },
  check: function (res, a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
      return res.send('wrong type');
    }
    res.next();
  }
};

// 使用中间件
server.registFunc('plus', plus)
  .registFunc('asyncPlus', asyncPlus)
  .registFunc('get', get)
  .registFunc('update', update)
  .registFunc('log', log)
  .use(middlewares.ip) //所有的hsf注册函数都会经过这个中间件，或者使用use('*', middlewares.ip)
  .use('log', middlewares.add) //指定注册的函数名称
  .use(['get', 'update'], middlewares.auth) //数组
  .use(/plus/i, middlewares.check) //正则
  .listen() //中间件与注册的函数之间的对应关系将在listen的时候才创建。中间件之间是有先后顺序的，但是与registFunc先后顺序无关
  .publish();
```

### HSFResponse

HSFResponse 会作为第一个参数传递给所有的中间件以及最终的处理函数。

### 字段：

```js
remoteAddress: 调用方的地址
socket: 与调用方之间的 socket
server: 属于的 hsf server
method: 这次调用的是哪个方法
starttime: 调用开始时间
```

### Access Log Middleware

自动记录 nginx 类似格式的 access log ，需要配合 [ali-logger](http://gitlab.alibaba-inc.com/edp/logger/tree/master) 使用，
或者你的 logger 实现了 `accessLog(ip, usec, method, url, status, bytes, referer, userAgent)` 接口.

使用方法:

```js
var logger = require('ali-logger');
// 初始化 logger
logger.init({
  logdir: '/tmp/testhsflogs',
  accessLog: true,
});

// 注册 accesslog 中间件
server.use(hsf.accesslog({logger: logger}));
```

## node调用HSF服务

```js
var hsf = require('hsf');
/**
 * create a new hsfClient
 * @param  {Object} options global config
 *  - {String} configSvr              configServer的host地址，默认为日常环境
 *  - {Number} connectTimeout         此client下全局的建立连接超时时间，默认为3秒
 *  - {Number} responseTimeout        此client下全局的响应超时时间，默认为3秒
 *  - {Number} routeInterval          此client下全局的向configSvr重新请求服务端地址、更新地址列表的间隔时间，默认为1分钟
 *  - {Boolean} snapshot              是否使用快照功能，使用快照则在启动的时候如果无法连接到config server，则读取本地缓存的服务者地址。
 *  - {String|Stream|function} logger 记录日志的路径或者Stream或者方法用于日志的写入
 *  - {Boolean} logOff                关闭日志
 *  - {Boolean} keepAlive             设置此client下生成的所有consumer是否与服务端维持长连接，默认为true
 *  - {Boolean} noDelay               设置此client下生成的所有consumer是否关闭nagle算法，默认为true
 * @return {HsfClient}
 * @public
 */
var client = hsf.createClient({});

/**
 * 创建一个consumer，可以同时创建多个consumer来调用多个HSF服务
 * @param  {string} interface   服务接口名
 * @param  {string} version     服务版本号
 * @param  {object} options
 *  - group                     服务分组，默认为hsf分组，一般不需要更改
 *  - routeInterval             此consumer的重新请求服务端地址、更新地址列表的间隔时间
 *  - connectTimeout            此consumer的建立连接超时时间
 *  - responseTimeout           此consumer的响应超时时间
 *  - id                        interface:version，在不传这两个参数的时候可以用id来替代
 *  - keepAlive                 此consumer是否与服务器维持长连接
 *  - noDelay                   此consumer是否关闭nagle算法
 * @return {Consumer}
 * @public
 */
var testConsumer = client.createConsumer('com.taobao.hsfcpp.service.nodejs', '1.0.0');

// 调用服务端的 plus 方法，第二个参数是调用 plus 方法时的参数数组，相当于调用 plus(3, 4);
testConsumer.invoke('plus', [3, 4], function (err, data) {
  // callback
});
```

注意：

* 应用在使用 `node-hsf` 来调用其他的 hsf 服务的时候，只需要用 `var client = hsf.createClient()` 创建一个全局的 `clinet`，根据不同的环境设置全局参数以及 configsrv 等。
* 可以通过 `var consumer = client.createConsumer()` 来创建对不同的hsf服务的调用的实例，
然后使用 `consumer.invoke('methodName', [args], callback)` 来调用服务方提供的hsf方法。
* `keepAlive` 选项: client 和 consumer 的初始化 options 中都有这个选项，
可以对全局或者单个的 consumer 设置是否采用长连接方式与服务端进行连接。如果应用对接口的调用量很小的时候（可能一天只用调用几十次），
建议设置 `keepAlive` 为 false ，当调用次数很高的时候设置 `keepAlive` 为 true ，性能上能有很大提升。默认为 `false`。

### node-hsf 调用 java 服务

由于 java 是强类型语言，而 HSF 的服务接口匹配规则是需要参数强制匹配的，
所以每次调用都需要确定类型名称，不能够再像调用 node 方法一样进行远程HSF服务调用。
因此，要调用一个 Java 的 HSF 服务，除了知道服务接口名和版本号之外，还需要知道其具体的方法以及参数。
通过要调用的 Java 服务方提供的 `Maven Dependency` 。

```xml
 <dependency>
  <groupId>com.taobao.tcif</groupId>
  <artifactId>tcif-lib</artifactId>
  <version>1.0.9</version>
</dependency>
```

可以在 [nexus 这里](http://mvnrepo.taobao.ali.com:8081/nexus/index.html#welcome) 获取到对应的 jar 包源码。
下载解压之后可以看到 Java HSF 服务的接口以及参数信息。
![search jar](http://gitlab.taobao.ali.com/uploads/note/attachment/848/maven.png)

获取到这些信息之后，根据下面的类型映射表格，来进行对应参数的调用。

#### Java 对象与 Node 的对应关系以及调用方法

|Java 类型|Node 类型|调用参数表示|备注|
|--------|--------|------------|----|
|NullObject|null or Undefined|`null` or `Undefined`|node中的null和Undefined默认对应到Java的NullObject
|boolean|Boolean|`{$class: 'boolean', $: true}` or `true`| |
|Java.lang.Boolean|Boolean|`{$class: 'java.lang.Boolean', $: true}`| |
|int|Integer|`{$class: 'int', $: 123}` or `123`|32位整型|
|java.lang.Integer|Integer|`{$class: 'java.lang.Integer', $: 123}`|32位整型|
|short|Integer|`{$class: 'short', $: 123}`|16位短整型，超出可能强制转换导致难以定位的bug|
|java.lang.Short|Integer|`{$class: 'java.lang.Short', $: 123}`|16位短整型，超出可能强制转换导致难以定位的bug|
|byte|Integer|`{$class: 'byte', $: 12}`|8位整型，超出可能强制转换导致难以定位的bug|
|java.lang.Byte|Integer|`{$class: 'java.lang.Byte', $: 12}`|16位短整型，超出可能强制转换导致难以定位的bug|
|long|Number|`{$class: 'long', $: 123456789}`|64位长整型，Number强制转换到int_64,超出范围可能导致难以定位的bug|
|java.lang.Long|Number|`{$class: 'java.lang.Long', $: 123456789}`|64位长整型，Number强制转换到int_64,超出范围可能导致难以定位的bug|
|double|Number|`{$class: 'double', $: 1.23}` or `1.23`|Node中的浮点数默认对应到Java的double|
|java.lang.Double|Number|`{$class: 'java.lang.Double', $: 1.23}`| |
|floeat|Number|`{$class: 'float', $: 1.23}`| |
|java.lang.Float|Number|`{$class: 'java.lang.Float', $: 1.23}`| |
|java.util.Date|Date|`new Date()`|node中的Date对象默认对应为java.util.Date|
|java.lang.String|String|`{$class: 'java.lang.String', $: '123'}` or `'123'`|Node中的String默认对应到java.lang.String|
|char|String|`{$class: 'char', $: '1'}`| |
|char[]|String|`{$class: 'char[]', $: '123'}`| |
|java.lang.Character|String|`{$class: 'java.lang.Character', $: '123'}`| |
|byte[]|Buffer|`new Buffer('abc', 'utf-8');`|Node中utf8编码的Buffer默认对应到Java中的byte[]|
|ArrayList|Array|`{$class: 'java.util.ArrayList', $: [1, 2, 3]}` or `[1, 2, 3]`|Node中的Array默认对应到Java中的java.util.ArrayList|
|java.util.List|Array|`{$class: 'java.util.List', $: [1, 2, 3]}`| |
|java.util.Set|Array|`{$class: 'java.util.Set', $: [1, 2, 3]}`| |
|java.util.Iterator|Array|`{$class: 'java.util.Iterator', $: [1, 2, 3]}`| |
|java.util.Enumeration|Array|`{$class: 'java.util.Enumeration', $: [1, 2, 3]}`| |
|java.util.HashMap|Object|`{$class: 'java.util.HashMap', $: {a: 1}}` or `{a: 1}`|Node中的Object默认对应到Java中的java.util.HashMap|
|java.util.Map|Object|`{$class: 'java.util.Map', $: {a: 1}}`|java.util.Map的key可以是任意类型，但是ndoe中的Object的key只能是string，此处待解决|
|java.util.Dictionary|Object|`{$class: 'java.util.Dictionary', $: {a: 1}}`| |
|com.taobao.testDO|Object|`{$class: 'com.taobao.testDO', $: {a: 1, b: {$class: 'long', $: 123456789}}}`|Java自定义对象形式|

#### Java 数组与 Node 的对应关系以及调用方法

|Java类型|Node类型|调用方法|
|--------|--------|------------|----|
|boolean[]|Array|`{$class: '[boolean', $: [true, false]}`|
|short[]|Array|`{$class: '[short', $: [1, 2]}`|
|int[]|Array|`{$class: '[int', $: [1, 2]}`|
|long[]|Array|`{$class: '[long', $: [1, 2]}`|
|float[]|Array|`{$class: '[float', $: [1.1, 2.2]}`|
|double[]|Array|`{$class: '[double', $: [1.1, 2.2]}`|
|Integer[]|Array|`{$class: '[java.lang.Integer', $: [1, 2]}`|
|Long[]|Array|`{$class: '[java.lang.Long', $: [1, 2]}`|
|String[]|Array|`{$class: '[string', $: ['1', '2']}`|
|Object[]|Array|`{$class: '[object', $: [{a: 1} ,{a: 2}]}`|
|XxxYyy[]|Array|`{$class: '[aaa.bbb.XxxYyy', $: [{a: 1}, {a: 2}]}`|

#### 注意事项

* 建议通过[js-to-java](https://github.com/node-modules/js-to-java) 来辅助编写 java 对象。
* 不支持key类型非`String`的对象。
* 调用Java自定义类型的时候，必须有完整的包名，`com.taobao.uic.common.domain.BaseDeliverAddressDO`。
* 如果不使用`{$class: 'name', $: value}`的形式传递参数，则按照默认的node向java对象映射进行调用。
* 当调用的java方法接受的参数是抽象类，而实际传递的参数需要是这个抽象类的子类的时候，例如HSF的服务方法为：

```java
void foo(AbstractClass obj);
```

`AbstractClass` 是抽象类，实际序列化传入的对象是它的子类：`ConcreteSubClass`。
那么此时在进行 HSF 调用时，一方面需要指定 `AbstractClass` 作为参数类型以让 HSF 能找到对应的方法，
另一方面又需要指定 `ConcreteSubClass` 使反序列化时能正确实例化对象。所以，需要多传递一个参数`$abstractClass`：

```js
{
  $class: 'com.taobao.ConcreteSubClass',       //子类名
  $abstractClass: 'com.taobao.AbstractClass',  //抽象父类名
  $: {a: 1, b: 'string'}
}
```

* 当需要传递 `java.lang.StringBuilder` 的 java 对象时，可以这样构造：

```java
StringBuilder str = 'StringBuilder';
```

=>

```js
var str = 'StringBuilder';
{
  $class: 'java.lang.StringBuilder',
  $: {
    value: {
      $class: '[char',
      $: str
    },
    count: str.length
  }
}
```

* 当需要传递 `java.util.Enumeration` 枚举类型的时候

```java
public enum RiskLevel {
  H,
  M,
  L
};
```

=>

```js
{
  $class: 'com.alibaba-buc.api.param.RiskLevel',
  $: {name: 'L'}
}
```

#### 调用实例

```js
var hsf = require('hsf');
var client = hsf.createClient({
  configSvr: '10.232.16.8'
});
var UicDeliverAddressService = client.createConsumer('com.taobao.uic.common.service.userinfo.UicDeliverAddressService',
  '1.0.0.daily');
var baseDeliverAddressDO = {
  $class: 'com.taobao.uic.common.domain.BaseDeliverAddressDO',
  $: {
    id: 13254,
    idLong: {
      $class: 'long',
      $: 13254
    },
    fullName: 'gongyangyu',
    phone: '123456789',
    mobile: '123456789',
    address: 'chuangyedasha',
    postCode: '310018',
    userId: {
      $class: 'long',
      $: 24567
    },
    status: 1,
    city: 'hangzhou',
    province: 'zhejiang',
    area: 'xihu',
    devisionCode: 'abcde',
    'addressDetail': 'huaxinlu99hao'
  }
};
var args = [baseDeliverAddressDO, 'gongyangyutest'];
UicDeliverAddressService.invoke('insertDeliverAddr', args, function(err, data) {
  console.log(err, data);
});
```

更多调用示例，查看 `test/invoke_java_test.js` 文件。

## node-hsf 性能测试工具

在 node-hsf 中提供了一个 hsf 服务的性能测试工具，可以通过这个小工具对自己的 server 进行性能测试。

```bash
benchmark [options]
example:./benchmark -i com.taobao.hsfcpp.service.nodejs.benchmark -v 1.0.0 -f plus -a [1,2] -n 20000 -c 50

Options:
  -n, --request     总请求数                                          [default: 100]
  -c, --concurrent  并发数                                           [default: 1]
  -s, --configsvr   config server地址                               [default: "commonconfig.taobao.net"]
  -i, --interface   服务提供者的接口名
  -v, --version     服务提供者的版本号
  -f, --function    调用方法名
  -a, --arguments   调用参数数组
  -t, --timeout     调用方法的超时时间
  -r, --result      预期结果值
  -l, --log         -l FILE, LOG to FILE.
  -T, --logType     log type, could be markdown/md, default text
  -C, --config      输入的json格式的config文件地址，包含测试参数，输出结果
```

## 注意事项

1. node 版本的 HSF 支持的数据结构：Number, String, Bool, Null, Undefined，Array，Object，Date，Buffer，不支持循环引用
2. 之前 HSF 客户端在 createConsumer 的时候，默认情况下如果以 `.daily` 结尾，则会自动设置分组为 `DAILYGROUP` 。
现在 HSF 更新之后，不再会自动设置到 `DAILYGROUP` ，将全部设置为 `HSF` 分组。
3. node-hsf 发布服务的时候，也不再会根据版本号自动选择分组，全部都默认设置为 `HSF` 分组，如果需要设置到 `DAILYGROUP` ，
请在创建服务的时候加入 `group` 参数来指定。

### 联系

如果有任何问题，请咨询[@不四](http://work.alibaba-inc.com/work/u/52624), @苏千.

### Authors

```bash
$ git summary

 project  : node-hsf
 repo age : 1 year, 3 months
 active   : 98 days
 commits  : 337
 files    : 71
 authors  :
   222  不四                  65.9%
    70  苏千                  20.8%
    23  dead-horse              6.8%
    18  heyiyu.pt               5.3%
     4  ????                    1.2%
```
