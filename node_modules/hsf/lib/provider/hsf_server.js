/*!
 * hsf - provider/hsf_server.js
 * Copyright(c) 2012 - 2013 Alibaba Group Holding Limited.
 * Authors:
 *   busi.hyy <busi.hyy@taobao.com>
 *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)
 */

/**
 * Module dependencies.
 */

var debug = require('debug')('hsf:server');
var net = require('net');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var Forwards = require('forwards');
var Cutter = require('cutter');
var transcode = require('../transcode');
var Limiter = require('./limiter');
var HSFResponse = require('./hsf_response');
var utils = require('../utils');
var createLogger = require('../logger');
var Middleware = require('./middleware');

var logger;
var AutoChecker;
var Publisher;

/**
 * HSFServer
 * @param {Object} options
 *  - {String} configSvr, default is 'commonconfig.taobao.net'
 *  - {String|Array} serviceName, default is 'com.taobao.hsfcpp.service.nodejs.demo'
 *  - {String|Array} version, default is '1.0.0'
 *  - {String} group, default is 'HSF', you can set it to 'DAILYGROUP'
 *  - {Number} port, default is `12200`
 *  - {String|WriteStream} logfile, log file path or log writable stream.
 *  - {Boolean} nohsf, not only hsf. Customized for nodejs, more faster. default true.
 *  - {Object} forwards, forwards info
 *    - {String} to, which server address want to forwards to. example: '127.0.0.1.12201'
 *    - {Number} reconnectTime, forwards reconnectTime
 *  - {Number} timeout, regist timeout to nitify java client
 *  - {String} diamondHost, if you want to push api meta info to hsf, you need to set this.
 *      daily: "commonconfig.taobao.net"
 *      pre | online: "commonconfig.config-host.taobao.com"
 * @constructor
 */
var HSFServer = function (options) {
  EventEmitter.call(this);
  this.options = options || {};
  this.funcs = {};
  this.middlewares = [];
  this._isPublish = false;
  this._hasInit = false;
  this._server = null;
  logger = createLogger(this.options);
  this.options.serviceName = this.options.serviceName || 'com.taobao.hsfcpp.service.nodejs.demo';
  this.options.version = this.options.version || '1.0.0';
  this.options.configSvr = this.options.configSvr || '10.232.16.8';
  this.options.port = parseInt(this.options.port, 10) || 12200;
  this.options._group = this.options.group || 'HSF';
  this.listenning = null;

  if (Array.isArray(this.options.serviceName)) {
    AutoChecker = require('./m_auto_checker');
    Publisher = require('./m_publisher');
    this.options._id = this.options.serviceName[0] + ':' + this.options.version[0];
  } else {
    AutoChecker = require('./auto_checker');
    Publisher = require('./publisher');
    this.options._id = this.options.serviceName + ':' + this.options.version;
  }

  //服务自检
  if (this.options.autoCheck) {
    this.autoChecker = AutoChecker.create(this.options);
    this.autoChecker.on('autocheck', this.emit.bind(this, 'autocheck'));
  }
  this._limiter = {};
  this._clientCount = 0;
  this.publisher = Publisher.createPublisher(this.options);
  this.middleware = Middleware.createMiddleware();
  //event binding
  this.publisher.on('error', this.emit.bind(this, 'configServerError'));
  this.publisher.on('CSconnect', this.emit.bind(this, 'CSconnect'));
  this.publisher.on('CSdisconnect', this.emit.bind(this, 'CSdisconnect'));
  this.on('connection', this.onConnection.bind(this));
  this.shouldKeepAlive = true;
};
util.inherits(HSFServer, EventEmitter);

HSFServer.prototype.publish = function (apiMeta) {
  if (!this._isPublish) {
    this.publisher.publish(apiMeta);
    this._isPublish = true;
    if (this.autoChecker) {
      this.once('CSconnect', function () {
        this.autoChecker.start();
      }.bind(this));
    }
  }
};

/**
 * Server listen.
 * @param {Number} [port]
 * @param  {Function} [callback]
 * @return {HSFServer}
 */
HSFServer.prototype.listen = function (port, callback) {
  if (!this.listenning) {
    if (typeof port === 'function') {
      callback = port;
      port = null;
    }
    this.middleware.start(this.funcs);
    this._server = net.createServer();
    this._server.on('connection', this.emit.bind(this, 'connection'));
    this._server.once('close', this._ServerClose.bind(this));
    this._server.listen(port || this.options.port, callback);
    logger.log('service listenning on ' + this.options.port);
    this.listenning = port || this.options.port;
  }
  return this;
};

/**
 * Stops the server from accepting new connections and keeps existing connections.
 *
 * @param {Function} [cb]
 */
HSFServer.prototype.close = function (cb) {
  if (!this._server) {
    if (cb) {
      process.nextTick(cb);
    }
    return;
  }
  this._server && this._server.close(cb);
  this._server = null;
  this.shouldKeepAlive = false;
};

HSFServer.prototype._ServerClose = function () {
  this._server = null;
  logger.log('server socket close()');
  logger.destroy();
};

/**
 * Server destroy.
 */
HSFServer.prototype.destroy = function () {
  if (this._isPublish) {
    this.publisher.unPublish();
    this.autoChecker && this.autoChecker.stop();
    logger.log('hsf service destroy()');
    this._isPublish = false;
    if (this._server) {
      this._server.close();
      this.listenning = null;
    }
  }
};

function getParamNames(fn) {
  var fnStr = fn.toString()
                .replace(/\/\*(.*?)\*\//g, '')
                .replace(/\/\/(.*?)\n/g, '')
                .replace(/\s/g, '');
  return fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).split(',');
}

/**
 * Regist the HSF Service function.
 * input format one: name and func. regist func use the name.
 * input format tow: object and name filter. regist all the funcs that match the filter in object.
 * filter can be null (no filter)
 *
 * @param  {String|Object} name, function name or Object
 * @param  {Function(res, arg1, arg2, ...)|RegExp} fn
 */
HSFServer.prototype.registFunc = function (name, fn) {
  if (typeof name === 'object') {
    var obj = name;
    var filter = fn;
    for (var key in name) {
      if (!name.hasOwnProperty(key) || typeof name[key] !== 'function') {
        continue;
      }
      if (filter && !key.match(filter)) {
        continue;
      }
      this.registFunc(key, name[key]);
    }
    return this;
  }
  this.funcs[name] = {
    handler: fn,
    paramNames: getParamNames(fn).slice(1) //first arguments is res
  };
  this.autoChecker && this.autoChecker.registFunc(name);
  logger.debug('regist func: %s', name);
  return this;
};

//alias for registFunc
HSFServer.prototype.regist = HSFServer.prototype.registFunc;

HSFServer.prototype.use = function (selector, fn) {
  this.middleware.use(selector, fn);
  //pm won't call `listen`, so need to start in each use
  this.middleware.start(this.funcs);
  return this;
};

/**
 * Set global limiter for hsf server
 *
 * @param  {Number} rate, target TPS.
 * @param  {Number} peak, peak limit.
 * @param  {Number} window, refresh time window. Default 1000, 1s.
 */
HSFServer.prototype.setGlobalLimiter = function(rate, peak, window) {
  this._globalLimiter = this._globalLimiter || Limiter.createLimiter(rate, peak, window);
  return this;
};

/**
 * Set limiter for hsf server function
 *
 * @param  {String} name, function name.
 * @param  {Number} rate, target TPS.
 * @param  {Number} peak, peak limit.
 * @param  {Number} window, refresh time window. Default 1000, 1s.
 */
HSFServer.prototype.setLimiter = function(name, rate, peak, window) {
  this._limiter[name] = this._limiter[name] || Limiter.createLimiter(rate, peak, window);
  return this;
};

HSFServer.prototype.unsetGlobalLimiter = function() {
  if (this._globalLimiter) {
    clearInterval(this._globalLimiter.timer);
    delete this._globalLimiter;
  }
  return this;
};

HSFServer.prototype.unsetLimiter = function(name) {
  var limiter = this._limiter[name];
  if (limiter) {
    clearInterval(limiter.timer);
    delete this._limiter[name];
  }
  return this;
};

HSFServer.prototype.callFunction = function (socket, input) {
  //var packetId = parseInt(input.packetId, 10);
  var packetId = input.packetId;
  var methodName = input.methodName || '';
  if (!methodName) {
    // heartbeat
    socket.write(transcode.responseEncode(packetId, 'a', null, input.nohsf));
    return;
  }
  if (packetId === null || packetId === undefined) {
    debug('client %s, input: %j, missing packetId', socket.remoteAddress, input);
    socket.end();
    return;
  }

  var args = input.args || [];
  if (!Array.isArray(args)) {
    debug('client %s, input: %j, params is not array', socket.remoteAddress, input);
    socket.write(transcode.responseEncode(packetId, 'e', 'parse params error', input.nohsf));
    return;
  }

  var func = this.funcs[methodName] && this.funcs[methodName].handler;
  if (!func) {
    var defFunc = this.funcs['_default'] && this.funcs['_default'].handler;
    if (defFunc) {
      methodName = '_default';
      func = defFunc;
    } else {
      debug('client %s, input: %j, can not find this method: %s',
        socket.remoteAddress, input, methodName);
      socket.write(transcode.responseEncode(packetId, 'e', 'can not find this method', input.nohsf));
      return;
    }
  }
  var globalLimiter = this._globalLimiter;
  if (globalLimiter) {
    if (globalLimiter.token === 0) {
      socket.write(transcode.responseEncode(packetId, 'e', this.options._id + ' traffic limit exceeded', input.nohsf));
      return;
    }
    globalLimiter.token--;
  }
  var limiter = this._limiter[methodName];
  if (limiter) {
    if (limiter.token === 0) {
      socket.write(transcode.responseEncode(packetId, 'e', this.options._id + '::' + methodName +
        ' traffic limit exceeded', input.nohsf));
      globalLimiter && globalLimiter.token++;
      return;
    }
    limiter.token--;
  }
  var res = new HSFResponse(this, socket, packetId, methodName, input.nohsf, this.shouldKeepAlive);
  args.unshift(res);
  //func.apply(this, args);
  this.middleware.run(methodName, args, func);
};

HSFServer.prototype.handleRequest = function (socket, data) {
  if (!socket.writable) {
    logger.logClient('socket can not writable', socket, '');
    return socket.end();
  }
  var input;
  try {
    input = transcode.requestDecode(data);
  } catch (err) {
    debug('decode request from %s error: %s', socket.remoteAddress, err.message);
    return socket.end();
  }
  this.callFunction(socket, input);
};

HSFServer.prototype.onConnection = function (socket) {
  //流量转发
  var forwards = this.options.forwards;
  if (forwards) {
    Forwards.connect(socket, forwards.to, forwards.reconnectTime);
  }

  //数据切割
  var cutter = new Cutter(14, utils.packetLength);
  cutter.on('packet', function (packet) {
    this.handleRequest(socket, packet);
  }.bind(this));
  socket.on('data', cutter.handleData.bind(cutter));

  //日志记录
  this._clientCount++;
  var ipPort = socket.remoteAddress + ':' + socket.remotePort;
  logger.log('[Client:' + ipPort + '] connected, total ' + this._clientCount);

  socket.on('error', function (err) {
    logger.log('[Client:' + ipPort + '] error: ' + err.stack);
    socket.end();
  }.bind(this));

  socket.on('close', function () {
    this._clientCount--;
    cutter.destroy();
    logger.log('[Client:' + ipPort + '] close, total ' + this._clientCount);
  }.bind(this));
};

/**
 * get address info from config server
 * if param is function, just callback the address.
 * @param {Function} callback
 * @private
 */
HSFServer.prototype.fetchAddress = function (callback) {
  utils.getAddress(this.options.configSvr, this.options._id, this.options._group, callback);
};

/**
 * Create HSFServer.
 * @param  {Object} options
 * @return {HSFServer}
 */
exports.createServer = function (options) {
  return new HSFServer(options);
};
