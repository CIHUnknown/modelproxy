/*!
 * hsf - provider/publisher.js
 * Copyright(c) 2012 - 2013 Alibaba Group Holding Limited.
 * Authors:
 *   busi.hyy <busi.hyy@taobao.com>
 *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)
 */

"use strict";

/**
 * Module dependencies.
 */

var debug = require('debug')('hsf:publisher');
var net = require('net');
var querystring = require('querystring');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var Diamond = require('diamond-client');
var redis = require('redis');
var transcode = require('../transcode');
var utils = require('../utils');

var logger;

var HEARTBEAT_PACKET = transcode.heartbeatEncode(1);

var Publisher = function (options) {
  EventEmitter.call(this);
  this.dataId = options._id || '';
  this.clientId = 'HSFProvider-' + this.dataId + '.1';
  this.group = options._group;
  this.port = options.port;
  this.localAddress = utils.getLocalAddress();
  this.configSvr = options.configSvr;
  this.revision = 1;
  logger = options.logger;
  //TODO change these to be configurable
  this.infos = {
    CLIENTRETRYCONNECTIONTIMES: 3,
    CLIENTRETRYCONNECTIONTIMEOUT: 1000,
    _SERIALIZETYPE: 'hessian',
    _IDLETIMEOUT: 600,
    _HSF: 'hsfnode' + utils.version,
    _NOHSF: options.nohsf === false ? '0' : '1',
    _TIMEOUT: options.timeout || 3000
  };
  this.retryInterval = 1000;
  //retry publish times;
  this.retryTimes = 0;
  //config server port
  this.CONFIG_PORT = 9600;
  //handle of socket with config server
  this.handle;
  this.heartBeatTimer;
  //hold publish data
  this.publishData;
  //mark status
  this.published = false;
  this.inited = false;
  this.destroy = false;
  //local ip address
  this.localAddress;
  //config server host ip
  this.csAddresses = [];
  this.useAddressIndex;
  //get config server host ip addresses
  this.refreshCSAddress();

  // get hsf redis host and port
  if (options.diamondHost) {
    this._diamond = Diamond.create({host: options.diamondHost});
  }
};

util.inherits(Publisher, EventEmitter);

Publisher.prototype.refreshCSAddress = function () {
  utils.getCSAddress(this.configSvr, function (err, data) {
    if (err || data.length === 0) {
      err = new Error('Can not get config server host addresses. ' + (err ? err.message : ''));
      err.name = 'ConfigSvrError';
      logger && logger.log('can not get config server host from config server ' + this.configSvr);
      process.nextTick(function() {
        this.emit('error', err);
      }.bind(this));
    }
    this.csAddresses = data || [];
    if (!this.inited) {
      this.inited = true;
      this.emit('init');
    }
    this.emit('refresh');
  }.bind(this));
};

/**
 * Publish service to HSF
 * @param {Object} apiMeta api meta info @see _pushMeta()
 */
Publisher.prototype.publish = function (apiMeta) {
  if (!this.inited) {
    this._apiMeta = apiMeta;
    return this.once('init', this.publish);
  }
  apiMeta = apiMeta || this._apiMeta;

  this.destroy = false;
  if (!this.published) {
    if (!this.publishData) {
      var publishList = [];
      //genarate publish data
      publishList.push(transcode.csRegistEncode(this.clientId, this.dataId, this.group, this.localAddress));
      publishList.push(transcode.csPublishEncode(this.clientId, this.dataId,
                            this.localAddress + ':' + this.port + '?' + querystring.stringify(this.infos), this.revision++));
      this.publishData = transcode.csDoPublishEncode(publishList);
    }
    //fetch address will choose same room first
    this.handle = net.connect(this.CONFIG_PORT, this.fetchAddress());
    this.handle.on('close', handleClose.bind(this));
    this.handle.on('error', handleError.bind(this));
    this.handle.once('data', function() {
      //if connect ok, reset retryInterval
      this.retryInterval = 1000;
      process.nextTick(function() {
        this.emit('CSconnect');
      }.bind(this));
    }.bind(this));
    this.handle.write(this.publishData);
    this.heartBeatTimer = setInterval(function() {
      this.handle.write(HEARTBEAT_PACKET);
    }.bind(this), 10000);
    this.published = true;

    if (this._diamond && apiMeta) {
      // push meta info to HSF redis
      this._diamond.on('com.taobao.hsf.redis', 'HSF', function (content) {
        debug('[%s] [%s] got redis: %s', process.pid, Date(), content);
        var item = content.split(':');
        var port = parseInt(item[1], 10);
        var host = item[0];
        this._redisPort = port;
        this._redisHost = host;
        this._pushMeta(apiMeta);
      }.bind(this));
    }
  }
};

/**
 * Push meta info to HSF
 * @param {Object} apiMeta
 *  {
 *    canonicalName: 'com.taobao.travelcom.item.cache.TravelCacheService',
 *    codeSource: 'travelcom-item-1.0.5.jar',
 *    methods: [{
 *      name: 'getTravelCache',
 *      parameterTypes: [
 *        'com.taobao.travelcom.item.domain.TravelCacheSwitchParam',
 *        'java.lang.String'
 *      ],
 *      returnType: 'com.taobao.travelcom.item.domain.TravelForestCache'
 *    }, ...]
 *  }
 */
Publisher.prototype._pushMeta = function (apiMeta) {
  var client = redis.createClient(this._redisPort, this._redisHost);
  // http://ops.jm.taobao.net/service-manager/module/api/redis/get.htm?key=com.taobao.travelcom.item.cache.TravelCacheService:1.0.0.daily.Metadata
  // com.taobao.travelcom.item.cache.TravelCacheService:1.0.0.daily.Metadata
  var key = this.dataId + '.Metadata';
  var name = this.dataId.split(':')[0];
  apiMeta.canonicalName = apiMeta.canonicalName || name;
  apiMeta.codeSource = apiMeta.codeSource || '';
  apiMeta = JSON.stringify(apiMeta);
  debug('[%s] [%s] push %s, meta: %s to HSF', process.pid, Date(), key, apiMeta);
  client.set(key, apiMeta, function (err) {
    if (err) {
      debug('[%s] [%s] push meta error: %s', process.pid, Date(), err);
    } else {
      debug('[%s] [%s] push meta success', process.pid, Date());
    }
    client.quit();
  });
};

Publisher.prototype.unPublish = function () {
  this.destroy = true;
  this.published = false;
  this.publishData = null;
  this.handle && this.handle.destroy();
};

function handleClose() {
  clearInterval(this.heartBeatTimer);
  if (this.destroy) {
    logger && logger.log('hsf provider unPublished');
    return;
  }
  process.nextTick(function() {
    this.emit('CSdisconnect');
  }.bind(this));
  logger && logger.log('connection with config server closed, retry publish after ' + this.retryInterval / 1000 + ' s');
  this.published = false;
  this.csAddresses.splice(this.useAddressIndex, 1);
  if (this.csAddresses.length === 0) {
    this.refreshCSAddress();
    this.once('refresh', function() {
      setTimeout(this.publish.bind(this), this.retryInterval);
      if (this.retryInterval < 128000) {
        this.retryInterval *= 2;
      }
    }.bind(this));
    return;
  }
  setTimeout(this.publish.bind(this), this.retryInterval);
  if (this.retryInterval < 128000) {
    this.retryInterval *= 2;
  }
}

function handleError(err) {
  logger && logger.log('config server error:' + err.message);
  return this.handle.end();
}
/**
 * first fetch the same room host
 * @param  {String} local
 * @param  {Array} addresses
 * @return {String}
 */
Publisher.prototype.fetchAddress = function () {
  var a1 = this.localAddress.split('.');
  var addresses = this.csAddresses;
  var a2;
  for (var i = 0, l = addresses.length; i < l; i++) {
    a2 = addresses[i].split('.');
    if (a1[0] === a2[0] && a1[1] === a2[1]) {
      this.useAddressIndex = i;
      return addresses[i];
    }
  }
  this.useAddressIndex = 0;
  return addresses[0];
};

exports.createPublisher = function (options) {
  return new Publisher(options);
};
