/**!
 * node-hsf - lib/consumer/nokeepalive_consumer.js
 *
 * Copyright(c) Alibaba Group Holding Limited.
 * MIT Licensed
 *
 * Authors:
 *   不四 <busi.hyy@taobao.com>
 *   苏千 <suqian.yf@alibaba-inc.com> (http://fengmk2.github.com)
 */

'use strict';

/**
 * Module dependencies.
 */

var util = require('util');
var net = require('net');
var debug = require('debug')('hsf:consumer:nokeepalive');
var Consumer = require('./keepalive_consumer');

module.exports = NoKeepaliveConsumer;

/**
 * 继承于Consumer类，实现了非长连接调用
 * @param {Object} options
 */
function NoKeepaliveConsumer(options) {
  Consumer.call(this, options);
}

util.inherits(NoKeepaliveConsumer, Consumer);

var proto = NoKeepaliveConsumer.prototype;

/**
 * providers在这里只有地址信息
 * @param {Array} addresses
 */
proto._refreshProviders = function (addresses) {
  if (addresses.length === 0) {
    return;
  }

  for (var i = 0, l = addresses.length; i < l; i++) {
    addresses[i].nohsf = String(addresses[i].query._NOHSF) === '1';
  }
  this._setProviders(addresses);
};

/**
 * 每次调用会从providers中选择一个地址，建立连接发送请求。
 * @param {Buffer} invokeBuf
 */
proto._handleInvoke = function (invokeBuf) {
  var address = this.providers[this.currentProvider];
  // no heartbeat
  address.query._IDLETIMEOUT = null;
  var client = this._createConnection(address);
  client.address = address;
  client.packetId = this.packetId;
  client.write(invokeBuf);
  this.invokes[this.packetId].client = client;
};

/**
 * 错误处理，如果error了，就把这个地址从providers中剔除
 * @param {Object} client 发生错误的连接
 * @param {Error} err
 */
proto._handleError = function (client, err) {
  // 在非keepAlive连接情况下，忽略掉close事件的处理
  if (err.name === 'HSFSocketClosed') {
    return;
  }

  var address = null;
  for (var i = 0, l = this.providers.length; i < l; i++) {
    address = this.providers[i];
    if (address === client.address) {
      debug('%s\'s provider get error: %s, host is %s',
        this.id, err.message, client.address.host);
      this.providers.splice(i, 1);
      this._finishInvoke(client.packetId, err);
      break;
    }
  }

  // make sure next sync emit new datas
  this.configclient.cleanCache(this.id, this.group);

  if (this.providers.length < this._minProviderCount) {
    if (this.providers.length === 0 && address) {
      // make sure providers not empty
      this.providers.push(address);
    }
    this._syncProviders();
  }
};
