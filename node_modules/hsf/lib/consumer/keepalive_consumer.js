/**!
 * node-hsf - lib/keepalive_consumer.js
 *
 * Copyright(c) 2012 - 2014 Alibaba Group Holding Limited.
 *
 * Authors:
 *  不四 <busi.hyy@taobao.com>
 *  苏千 <suqian.yf@alipay.com> (http://fengmk2.github.com)
 */

'use strict';

/**
 * Module dependencies.
 */

var debug = require('debug')('hsf:consumer:keepalive');
var net = require('net');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var path = require('path');
var urlparse = require('url').parse;
var Cutter = require('cutter');
var transcode = require('../transcode');
var utils = require('../utils');

module.exports = Consumer;

// Consumer init flows
// 1. get config server ip list from config master ip
// 2. get service provider ip list from config server
// 3. create one connection from on provider and start heartbeat

/**
 * hsf consumer
 * @param {Object} options consumer config
 * @constructor
 */
function Consumer(options) {
  EventEmitter.call(this);

  this.id = options.id;
  this.responseTimeout = options.responseTimeout;
  this.routeInterval = options.routeInterval;
  this.group = options.group;
  this.trafficStatistics = options.trafficStatistics;
  this.noDelay = options.noDelay === false;
  this.inTraffic = 0;
  this.outTraffic = 0;
  this.inited = false;
  this.providers = [];
  this._minProviderCount = 0; // 最少要求的 providers 数量
  this.currentProvider = 0;
  this.packetId = 0;
  this.invokes = {};
  this.reqByError = false;
  this.configclient = options.configclient;
  this.logger = options.logger || console;

  this._init();
  this._startTimers();
}

util.inherits(Consumer, EventEmitter);

var proto = Consumer.prototype;

// public methods

/**
 * get connected providers addresses
 * @public
 */
proto.fetchAddress = function() {
  var addresses = [];
  for (var i = 0; i < this.providers.length; i++) {
    addresses.push(this.providers[i].address.host);
  }
  return addresses;
};

/**
 * clear traffic statistics data
 * @param {String} which if `in`, clear inTraffic, if `out`, clear outTraffic. else clear both
 * @api public
 */
proto.clearTraffic = function (which) {
  switch (which) {
  case 'in':
    this.inTraffic = 0;
    break;
  case 'out':
    this.outTraffic = 0;
    break;
  default:
    this.inTraffic = 0;
    this.outTraffic = 0;
  }
};

/**
 * get traffic statistics data
 * @api public
 * @return {Object} traffic data info
 */
proto.getTraffic = function () {
  return {
    inTraffic: this.inTraffic,
    outTraffic: this.outTraffic
  };
};

proto.ready = function (callback) {
  if (this.inited) {
    return callback();
  }
  this.once('init', callback);
};

proto.close = function () {
  if (this.clearTimer) {
    clearInterval(this.clearTimer);
    this.clearTimer = null;
  }
  if (this._dataListener) {
    this.configclient.removeAllListener(this.id, this.group, this._dataListener);
  }
};

/**
 * do hsf invoke
 * @param  {String}   name      function name
 * @param  {Array}    args      function arguments
 * @param  {Function} callback
 * @public
 */
proto.invoke = function (name, args, callback) {
  if (typeof args === 'function') {
    callback = args;
    args = [];
  }
  if (!(Array.isArray(args))) {
    args = [args];
  }

  var err;
  if (typeof name !== 'string') {
    err = new Error('First argument `' + name + '` must be function name!');
    err.name = 'HSFInvokeParameterError';
    return callback(err);
  }

  if (!this.inited) {
    this.once('init', function () {
      this.invoke(name, args, callback);
    }.bind(this));
    return ;
  }

  if (this.providers.length === 0) {
    // console.log('%s [No provider]Can not get address info from config server!', new Date());
    err = new Error('[No provider] Can not get "' + this.id + ':' + name + '()" address info from config server!');
    err.name = 'HSFNoProviderError';
    err.data = {
      method: name,
      serviceId: this.id,
      args: args,
    };
    debug('invoke %s with method `%s` and args %j but no provider',
      this.id, name, args);
    return callback(err);
  }

  // get the invoke request packet
  var invokeBuf;
  var packetId = ++this.packetId;
  this.currentProvider = (this.currentProvider + 1) % this.providers.length;
  try {
    invokeBuf = transcode.requestEncode(this.id, name, packetId, args,
      this.providers[this.currentProvider].nohsf);
  } catch (err) {
    // console.log('%s Encode HSF request error: %s', new Date(), err.message);
    err.name = 'HSFEncodeRequestError';
    err.data = {
      method: name,
      serviceId: this.id,
      args: args
    };
    debug('invoke %s with method %s error: %s',
      this.id, name, err.message);
    return callback(err);
  }
  if (this.trafficStatistics) {
    this.outTraffic += invokeBuf.length;
  }
  this.invokes[this.packetId] = {
    callback: callback,
    time: Date.now(),
    name: name,
    args: args
  };
  debug('invoke %s with method `%s`, packetId is %d',
    this.id, name, this.packetId);
  this._handleInvoke(invokeBuf);
};

// private methods

proto._init = function () {
  this._dataListener = function (addresses) {
    this._refreshProviders(addresses);

    if (this.providers.length === 0) {
      debug('_init() error: %s no exists providers, need to sync after 1 second', this.id);
      if (!this.inited) {
        var err = new Error(this.id + ':' + this.group  + ' has no providers');
        err.name = 'HSFConsumerInitError';
        this.logger.error(err);
      }

      // must sync again
      return setTimeout(this._syncProviders.bind(this), 1000);
    }

    if (!this.inited && this.providers.length > 0) {
      this.inited = true;
      this.emit('init');
      this.logger.log('HSFConsumer %s:%s inited success, got %d providers',
        this.id, this.group, this.providers.length);
    }
  }.bind(this);

  // when providers change, will emit this
  this.configclient.on(this.id, this.group, this._dataListener);
};

proto._startTimers = function () {
  // 超时清理逻辑
  this.clearTimer = setInterval(function () {
    var now = Date.now();
    for (var packetId in this.invokes) {
      var invoke = this.invokes[packetId];
      var rt = now - invoke.time;
      if (rt > this.responseTimeout) {
        var msg = 'HSF response timeout, ' + rt + 'ms > ' + this.responseTimeout + 'ms';
        var err = new Error(msg);
        err.name = 'HSFResponseTimeoutError';
        this._finishInvoke(packetId, err);
      }
    }
  }.bind(this), 100);
  // TODO: 大量累积请求的话, 每 100ms 去遍历一次, 感觉会有问题
};

proto._finishInvoke = function (packetId, err, data) {
  var invoke = this.invokes[packetId];
  delete this.invokes[packetId];
  if (data instanceof Error) {
    err = err || data;
  }
  if (err) {
    err.name = 'HSFResponseError';
    err.message = this.id + ':' + invoke.name + '()#' + packetId
      + ' error: ' + err.message;
    err.data = {
      method: invoke.name,
      serviceId: this.id,
      args: invoke.args
    };
    debug('packetId %d, invoke error: %s', packetId, err.message);
  } else {
    debug('packetId %d, invoke ok', packetId);
  }
  invoke.callback(err, data);
};

proto._syncProviders = function () {
  this.configclient.syncOne(this.id, this.group, true);
};

proto._setProviders = function (providers) {
  // 0 => 1
  // 1 => 1
  // 2 => 1
  // 3 => 2
  // 5 => 3
  this._minProviderCount = Math.ceil(providers.length / 2);
  if (this._minProviderCount <= 0) {
    this._minProviderCount = 1;
  }
  this.providers = providers;
};

/**
 * refresh providers by given addresses.
 * @param {Array} addresses. Array of address such as [{
 *  host: '127.0.0.1:12200', port: '12200', hostname: '127.0.0.1', ...}]
 */
proto._refreshProviders = function (addresses) {
  debug('_refreshProviders(): %s got %d providers, inited %s',
    this.id, addresses.length, this.inited);
  if (addresses.length === 0) {
    return;
  }

  var oldProviders = this.providers;
  var newProviders = [];
  var closeProviders = [];

  var oldMap = {};
  for (var i = 0; i < oldProviders.length; i++) {
    var p = oldProviders[i];
    oldMap[p.address.host] = p;
  }

  for (var i = 0, la = addresses.length; i < la; i++) {
    var address = addresses[i];
    if (!address.hostname || !address.port) {
      continue;
    }

    var provider = null;
    var oldProvider = oldMap[address.host];
    if (oldProvider) {
      // 如果存在, 则需要判断是否可写
      if (oldProvider.client.writable) {
        // keep the old provider
        provider = oldProvider;
        debug('keep old provider: %s', provider.address.host);
      } else {
        // 不可写的需要关闭它, 重新连接
        closeProviders.push(oldProvider);
      }
    }

    if (!provider) {
      debug('add new provider: %s', address.host);
      var client = this._createConnection(address);
      var nohsf = String(address.query._NOHSF) === '1';
      provider = {
        address: address,
        client: client,
        nohsf: nohsf,
      };
    }

    newProviders.push(provider);
  }

  this._setProviders(newProviders);
  for (var i = 0; i < closeProviders.length; i++) {
    var p = closeProviders[i];
    debug('remove old provider: %s', p.address.host);
    this._closeConnection(p.client);
  }
  debug('%s got total %s, %s news, remove %s old providers',
    this.id, addresses.length, newProviders.length, closeProviders.length);
  this.logger.log('[HSFKeepaliveConsumer] %s got total %s, %s news, remove %s old providers',
    this.id, addresses.length, newProviders.length, closeProviders.length);
};

proto._createConnection = function (address) {
  var client = net.connect(address.port, address.hostname);
  client.setNoDelay(this.noDelay);
  this._bind(client, address);
  return client;
};

proto._closeConnection = function (client) {
  if (client._isClosed) {
    return;
  }

  setTimeout(function () {
    // 如果在等待的这段时间里, 已经被 close 了, 则不需要再处理了.
    if (!client._isClosed) {
      client.end();
    }
  }, this.responseTimeout);
};

proto._handleInvoke = function (invokeBuf) {
  var provider = this.providers[this.currentProvider];
  debug('_handleInvoke() invoke through by %s', provider.address.host);
  provider.client.write(invokeBuf);
};

/**
 * handle response from hsf provider
 * @param {Socket} client
 * @param {Buffer} packet, response packet.
 */
proto._handleResponse = function (client, packet, address) {
  var response;
  try {
    response = transcode.responseDecode(packet) || {};
  } catch (err) {
    err.name = 'HSFTranscodeDecodeError';
    return this._handleError(client, err);
  }

  var packetId = response.packetId;
  var invoke = this.invokes[packetId];
  if (!this.invokes[packetId]) {
    // heartbeat or already invoked
    return;
  }
  var err;
  if (response.isError && response.errorMsg) {
    err = new Error(response.errorMsg);
  } else if (response.appResponse instanceof Error) {
    err = response.appResponse;
  }

  if (err) {
    err.name = 'HSFResponseError';
    debug('%s error %s, %s, %j', this.id, err.name + ': ' + err.message, invoke.name, invoke.args);
    if (address) {
      err.message += '\nhost: ' + address.host;
    }
    return this._finishInvoke(packetId, err);
  }

  this._finishInvoke(packetId, null, response.appResponse);
};

/**
 * handle response from hsf provider
 * @param  {socket}   client
 */
proto._bind = function (client, address) {
  var nohsf = String(address.query._NOHSF) === '1';
  var heartbeat = address.query._IDLETIMEOUT ? parseInt(address.query._IDLETIMEOUT, 10) : null;
  if (heartbeat) {
    // half _IDLETIMEOUT interval
    heartbeat = parseInt(heartbeat/ 2 * 1000);
    if (heartbeat < 5000) {
      heartbeat = 5000;
    }

    if (heartbeat) {
      client.heartbeatTimer = setInterval(function () {
        client.write(transcode.heartbeatEncode(++this.packetId, nohsf));
      }.bind(this), heartbeat);
    }
  }

  var cutter = new Cutter(14, utils.packetLength);
  cutter.on('packet', function (packet) {
    this._handleResponse(client, packet, address);
  }.bind(this));

  client.on('data', function (data) {
    if (this.trafficStatistics) {
      this.inTraffic += data.length;
    }
    cutter.emit('data', data);
  }.bind(this));

  client.on('close', function () {
    cutter.destroy();

    var err = client._lastError;
    if (!err) {
      var err = new Error(address.host + ' client closed.');
      err.name = 'HSFConsumerSocketClosed';
    }
    debug('[_bind()] client close: %s', err.message);
    this._handleError(client, err);

    // clean client resources
    if (client.heartbeatTimer) {
      clearInterval(client.heartbeatTimer);
      client.heartbeatTimer = null;
    }
    client.removeAllListeners();
    client._isClosed = true;
  }.bind(this));

  client.on('error', function (err) {
    err.name = 'HSFConsumerRequestError';
    err.message += '\nid: ' + this.id + '\nhost: ' + address.host;
    this.logger.error(err);

    debug('[_bind()] client error: %s', err.message);
    client._lastError = err;
    // Emitted when an error occurs. The 'close' event will be called directly following this event.
  }.bind(this));
};

// subclass alway need to impl this
// handle request error, remove this error socket and so on
proto._handleError = function (client, err) {
  var provider;
  for (var i =  0, l = this.providers.length; i < l; i++) {
    provider = this.providers[i];
    if (provider.client === client) {
      debug('%s\'s provider get error: %s, host is %s',
        this.id, err.message, provider.address.host);
      // 没有办法确认是那个 packetId, 所以不能在这里调用 _finishInvoke 来错误返回
      this.providers.splice(i, 1);
      break;
    }
  }

  // make sure next sync emit new datas
  this.configclient.cleanCache(this.id, this.group);

  if (this.providers.length < this._minProviderCount) {
    if (this.providers.length === 0 && provider) {
      // try to hard to make sure prvoiders list not empty
      debug('_handleError() %s add new provider: %j', this.id, provider.address.host);
      var newClient = this._createConnection(provider.address);
      var nohsf = String(provider.address.query._NOHSF) === '1';
      this.providers.push({
        address: provider.address,
        client: newClient,
        nohsf: nohsf,
      });
    }
    // sync again
    this._syncProviders();
  }
};
