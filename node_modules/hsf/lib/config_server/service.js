/*!
 * node-hsf - lib/config_server/service.js
 * Copyright(c) 2013 Taobao.com
 * Author: busi.hyy <busi.hyy@taobao.com>
 */

"use strict";

/**
 * Module dependencies.
 */
var proxy = require('../utils');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var fs = require('fs');
var path = require('path');

/**
 * Service addresses from config server
 * @param {Object} options
 *   - {String} configSvr        config server address. Default is dev's 10.232.16.8
 *   - {String} id               data id, such as 'com.taobao.com.nodejs:1.0.0.daily'
 *   - {String} group            group info, such as 'HSF'
 *   - {Number} routeInterval.   route config server get addresses's interval. default 60000
 *   - {String|Bolean} snapshot  set false to unuse get addresss from snapshot. or give a snapshot path. Default is `__dirname`/snapshot/id:version
 */
var Service = function (options) {
  EventEmitter.call(this);
  options = options || {};
  if (!options.configSvr) {
    console.warn('Use default config server: 10.232.16.8');
  }
  this.configSvr = options.configSvr || '10.232.16.8';
  if (!options.id || !options.group) {
    throw new Error('need id, version and group');
  }
  this.init = false;
  this.id = options.id;
  this.snapshot = options.snapshot === false ? null : (options.snapshot || path.join(__dirname, 'snapshot', this.id));
  this.group = options.group;
  this.routeInterval = options.routeInterval || 60000;
  this.addresses = [];
  this.bind();
};
util.inherits(Service, EventEmitter);


/**
 * getAddress fro config server
 * when ` typeof callback === 'function'`(initiative invoke), `this.addresses` will update whatever.
 * otherwise(polling invoke), when addresses is empty array, it won't change `this.addresses`
 * @param {Function} callback   If initiative call getAddress, need have callback
 * @return {[type]} [description]
 */
Service.prototype.refreshAddress = function (callback) {
  var self = this;
  function cb(err, addresses) {
    self.init = true;
    if (err || !addresses.length) {
      //if polling invoke get an empty array, just ignore it.
      //if initiative invoke get an empty array, means address arrays really is empty.
      self.addresses = callback ? [] : self.addresses;
      callback && callback(err, addresses);
      return err ? self.emit('getAddressError', err) : self.emit('empty');
    }
    if (addresses.length !== self.addresses.length) {
      self.addresses = addresses;
      self.emit('change', addresses);
    } else {
      var count = 0;
      //compare address.host, if no change, just do nothing.
      for (var i = 0; i < self.addresses.length; i++) {
        for (var j = 0; j < addresses.length; j++) {
          if (self.addresses[i].host === addresses[j].host) {
            count++;
            break;
          }
        }
      }
      if (count !== self.addresses) {
        self.addresses = addresses;
        self.emit('change', addresses);
      }
    }
    callback && callback(err, addresses);
  }
  proxy.getAddress(this.configSvr, this.id, this.group, function (err, addresses) {
    if (!self.init && self.snapshot && (err || !addresses.length)) {
      return proxy.getAddressFromSnapshot(self.snapshot, cb);
    }
    cb(err, addresses);
    addresses && addresses.length && self.snapshot && proxy.takeSnapshot(self.snapshot);
  });
};

Service.prototype.getAddress = function () {
  return this.addresses;
};

Service.prototype.kickOut = function (host) {
  var addresses = this.addresses;
  var flag = false;
  for (var i = 0; i < addresses.length; i++) {
    if (addresses[i].host === host) {
      addresses.splice(i, 1);
      flag = true;
      break;
    }
  }
  if (!addresses.length) {
    this.refreshAddress(function () {});  //refresh addresses
  }
  return flag;
};

Service.prototype.bind = function () {
  this.timer = setInterval(this.refreshAddress.bind(this), this.routeInterval);
  process.nextTick(this.refreshAddress.bind(this));
};

Service.prototype.distroy = function() {
  clearInterval(this.timer);
  this.timer = null;
  this.addresses = [];
};

module.exports = Service;
