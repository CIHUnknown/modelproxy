/**!
 * node-hsf - lib/config_client.js
 *
 * Copyright(c) Alibaba Group Holding Limited.
 * MIT Licensed
 *
 * Authors:
 *   苏千 <suqian.yf@alibaba-inc.com> (http://fengmk2.github.com)
 */

'use strict';

/**
 * Module dependencies.
 */

var debug = require('debug')('hsf:config_client');
var urlparse = require('url').parse;
var path = require('path');
var crc = require('buffer-crc32').signed;
var fs = require('fs');
var EventEmitter = require('events').EventEmitter;
var urllib = require('urllib');
var osenv = require('osenv');
var mkdirp = require('mkdirp');
var transcode = require('./transcode');

var VERSION = require('../package.json').version;
var USER_AGENT = 'node-config-client/' + VERSION + ' ' + urllib.USER_AGENT;

module.exports = ConfigClient;

function ConfigClient(options) {
  this._events = new EventEmitter();
  this._masterIp = options.masterIp || '10.232.16.8';
  this._port = options.port || 9603;
  this._root = options.root || '/config-sdk';
  this._timeout = options.timeout || 10000;
  this._refreshInterval = options.refreshInterval || 30000;
  this._snapshot = !!options.snapshot;
  this._snapshotDir = options.snapshotDir;
  if (!this._snapshotDir) {
    this._snapshotDir = path.join(osenv.tmpdir(), 'node_hsf_config_snapshots');
  }
  if (this._snapshot) {
    mkdirp.sync(this._snapshotDir);
  }

  this._currentMasterIndex = 0;
  this._masters = [];
  this._configs = {};

  this._syncMasters();
  this._syncTimer = setInterval(this._syncAll.bind(this), this._refreshInterval);
  this.logger = options.logger || console;

  this.logger.log('[HSFConfigClient] to %s:%s%s created, snapshot: %s',
    this._masterIp, this._port, this._root, this._snapshot);
}

var proto = ConfigClient.prototype;

proto.close = function () {
  clearInterval(this._syncTimer);
  this._syncTimer = null;
  this.removeAllListeners();
};

proto._getOneMaster = function () {
  this._currentMasterIndex++;
  if (this._currentMasterIndex >= this._masters.length) {
    this._currentMasterIndex = 0;
  }
  return this._masters[this._currentMasterIndex] || this._masterIp;
};

proto._createRequest = function (id, group) {
  var body = transcode.genReqBody(id, group);
  var args = {
    type: 'POST',
    headers: {
      'config-sdk' : '1.5',
      'User-Agent' : USER_AGENT
    },
    data: body
  };
  return args;
};

proto._parseResponse = function (body, id, group) {
  // body is hessian string: http://hessian.caucho.com/doc/hessian-1.0-spec.xtp#string
  var infos = body.toString('ascii', 3).split(/\n|;/);
  var map = {};
  var result = [];
  for (var i = 0; i < infos.length; i++) {
    var info = infos[i];
    if (info.trim() === '') {
      continue;
    }
    if (info.indexOf('://') === -1) {
      info = 'hsf://' + info;
    }
    var address = urlparse(info, true);
    if (!map[address.host]) {
      map[address.host] = true;
      if (address.port) {
        address.port = parseInt(address.port, 10);
      }
      result.push(address);
    }
  }
  return result;
};

proto._request = function (id, group, callback) {
  var args = this._createRequest(id, group);
  args.timeout = args.timeout || this._timeout;

  var url = 'http://' + this._getOneMaster() + ':' + this._port + this._root;
  urllib.request(url, args, function (err, body, res) {
    if (err) {
      err.name = 'HSFConfigClient' + err.name;
      err.message += '\nid: ' + id + ', group: ' + group +
        '\nurl: ' + url;
    }
    // request http://10.232.16.8:9603/config-sdk got 200,
    // headers {"content-type":"text/html; charset=UTF-8","date":"Tue Apr 08 14:42:22 CST 2014",
    // "server":"ConfigHttpServer/1.0","content-length":"54","connection":"keep-alive"}
    debug('request %s:%s: %s got %s, headers %j',
      id, group, url, res && res.statusCode, res && res.headers);
    callback(err, body, res);
  });
};

proto._syncMasters = function () {
  var that = this;
  that.on('com.taobao.config.serverlist', 'DEFAULT_GROUP', function (addresses) {
    if (addresses.length > 0) {
      that._masters = addresses.map(function (item) {
        return item.hostname;
      });
      // that._masters.push(this._masterIp);
      debug('got new master list: %j', that._masters);
    }
  });
};

proto._syncAll = function () {
  for (var key in this._configs) {
    var item = this._configs[key];
    this.syncOne(item.id, item.group);
  }
};

proto._snapshotFilepath = function (id, group) {
  return path.join(this._snapshotDir, id + '.' + group + '.json');
};

proto._takeSnapshot = function (id, group, items) {
  if (!this._snapshot) {
    return;
  }

  var filepath = this._snapshotFilepath(id, group);
  var data;
  var that = this;

  try {
    data = JSON.stringify(items);
  } catch (err) {
    err.name = 'HSFConfigClientTakeSnapshotError';
    err.message += '\nfilepath: ' + filepath + '\nid: ' + id + '\ngroup: ' + group
      + '\nitems length: ' + (items && items.length || 0);
    that.logger.error(err);
    return;
  }

  fs.writeFile(filepath, data, function (err) {
    if (err) {
      err.name = 'HSFConfigClientTakeSnapshotError';
      err.message += '\nfilepath: ' + filepath + '\nid: ' + id + '\ngroup: ' + group
        + '\nitems: ' + data;
      that.logger.error(err);
      return;
    }
    that.logger.log('[HSFConfigClient] save %s:%s snapshot to %s success', id, group, filepath);
  });
};

proto._restoreFromSnapshot = function (id, group, callback) {
  if (!this._snapshot) {
    return callback();
  }

  var filepath = this._snapshotFilepath(id, group);
  var that = this;
  fs.exists(filepath, function (exists) {
    if (!exists) {
      that.logger.warn('[HSFConfigClient] snapshot %s not exists', filepath);
      return callback();
    }
    fs.readFile(filepath, function (err, data) {
      if (err) {
        err.name = 'HSFConfigClientRestoreFromSnapshotError';
        err.message += '\nfilepath: ' + filepath + '\nid: ' + id + '\ngroup: ' + group
          + '\nitems length: ' + (items && items.length || 0);
        that.logger.error(err);
        return callback();
      }
      var items = null;
      try {
        items = data.length > 0 ? JSON.parse(data) : null;
      } catch (err) {
        err.name = 'HSFConfigClientRestoreFromSnapshotError';
        err.message += '\nfilepath: ' + filepath + '\nid: ' + id + '\ngroup: ' + group
          + '\nitems length: ' + (items && items.length || 0);
        that.logger.error(err);
      }
      callback(null, items);
    });
  });
};

// public methods

// clean cache, make sure next sync emit data event
proto.cleanCache = function (id, group) {
  var key = id + ':' + group;
  var data = this._configs[key];
  if (data) {
    data.crc32 = null;
  }
};

proto.syncOne = function (id, group, force, retries) {
  var that = this;
  var key = id + ':' + group;
  var data = that._configs[key];
  if (!data) {
    return;
  }

  that._request(data.id, data.group, function (err, body) {
    retries = retries || 0;

    if (err) {
      that.logger.error(err);
      body = null;
    }

    var value = [];
    var crc32 = -1;
    if (body) {
      crc32 = crc(body);
      debug('%s config current crc: %s, last: %s, retries: %s', key, crc32, data.crc32, retries);
      if (data.crc32 === crc32) {
        debug('%s config no change', key);
        // not change
        if (force) {
          that._events.emit(key, data.value);
        }
        return;
      }

      value = that._parseResponse(body, id, group);
    }

    if (value.length === 0 && !data.value) {
      // first get, need to retry
      if (retries < 3) {
        debug('syncOne() %s first got empty, retry', key);
        return process.nextTick(function () {
          that.syncOne(id, group, force, ++retries);
        });
      } else if (retries === 3) {
        // try to restore from snapshot after reties all fails
        that.logger.warn('[HSFConfigClient] fetch %s:%s config fails, trying to restore from snapshot',
          id, group);
        return that._restoreFromSnapshot(id, group, function (_, items) {
          if (!items) {
            var err = new Error('Fetch config from server and snapshot all fails, retry after 5s');
            err.message += '\nid: ' + id + '\ngroup: ' + group;
            err.name = 'HSFConfigClientInitError';
            that.logger.error(err);
            that._events.emit('error_' + key, err);
            // retry after 5s
            setTimeout(that.syncOne.bind(that, id, group, force), 5000);
            return;
          }

          if (data.value) {
            that.logger.warn('[HSFConfigClient] %s:%s config exists, dont use the snapshot result', id, group);
            return;
          }

          // success
          data.value = items;
          that._configs[key] = data;
          debug('%s config from snapshot got %j, force: %s', key, data.value, force);
          that._events.emit(key, data.value);
        });
      }
    }

    if (value.length === 0) {
      // empty ignore it
      return;
    }

    if (!data.value) {
      // first got
      that.logger.log('[HSFConfigClient] got %s:%s config success, items count: %d', id, group, value.length);
      // remove error listener
      that._events.removeAllListeners('error_' + key);
    }

    data.value = value;
    data.crc32 = crc32;
    that._configs[key] = data;

    debug('%s config got %j, crc32: %s, force: %s', key, data.value, crc32, force);
    that._events.emit(key, data.value);

    that._takeSnapshot(id, group, value);
  });
};

// 监听 id 和 group 的变化, 只要 id 和 group 对应的 providers 信息变化了,
// 都会通过 callback 通知变化之后的值
proto.on = function (id, group, callback) {
  var key = id + ':' + group;
  this._events.on(key, callback);

  var exists = this._configs[key];
  if (!exists) {
    this._configs[key] = {
      id: id,
      group: group,
      crc32: null,
      value: null
    };
    this.syncOne(id, group);
  } else if (exists.value) {
    // 第一次监听, 已经存在了, 则立即通知一次
    process.nextTick(function () {
      callback(exists.value);
    });
  }
};

proto.onError = function (id, group, callback) {
  this._events.on('error_' + id + ':' + group, callback);
};

// 移除一组对 id 和 group 的监听
proto.removeAllListener = function (id, group, callback) {
  var key = id + ':' + group;
  this._events.removeListener(key, callback);

  var listeners = this._events.listeners(key) || [];
  if (listeners.length === 0) {
    delete this._configs[key];
  }
};

// 移除对 id 和 group 的所有监听
proto.removeAllListeners = function (id, group) {
  var key = id + ':' + group;
  this._events.removeAllListeners(key);
  this._events.removeAllListeners('error_' + key);
  delete this._configs[key];
};
