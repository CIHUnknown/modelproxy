{
  "name": "hsf",
  "description": "HSF的Node.js实现，可以发布hsf服务以及调用java的hsf服务",
  "version": "1.0.0-beta9",
  "homepage": "http://gitlab.alibaba-inc.com/edp/node-hsf",
  "repository": {
    "type": "git",
    "url": "git@gitlab.alibaba-inc.com:edp/node-hsf.git"
  },
  "bugs": {
    "url": "http://gitlab.alibaba-inc.com/edp/node-hsf/issues"
  },
  "dependencies": {
    "buffer-crc32": "0.2.1",
    "copy-to": "1.0.1",
    "cutter": "0.0.3",
    "debug": "0.8.1",
    "diamond-client": "0.0.7",
    "forwards": "0.0.4",
    "hsf-protocol": "0.0.10",
    "mkdirp": "0.4.0",
    "nan": "0.8.0",
    "osenv": "0.0.3",
    "redis": "0.10.1",
    "urllib": "0.5.14",
    "utility": "0.1.13"
  },
  "devDependencies": {
    "address": "0.0.3",
    "ali-contributors": "*",
    "ali-logger": "0.4.1",
    "alicov": "*",
    "autod": ">=0.0.10",
    "blanket": "*",
    "iconv-lite": "0.2.11",
    "js-to-java": "1.0.0",
    "jshint": "*",
    "mm": "0.2.1",
    "mocha": "*",
    "pedding": "0.0.3",
    "should": "3.3.1"
  },
  "author": {
    "name": "busi.hyy",
    "email": "busi.hyy@taobao.com",
    "url": "http://dead-horse.github.com"
  },
  "main": "./index.js",
  "scripts": {
    "test": "make test-all"
  },
  "config": {
    "blanket": {
      "pattern": "//^((?!(node_modules|test)).)*$/",
      "data-cover-flags": {
        "debug": false
      }
    },
    "alicov": {
      "threshold": 97
    }
  },
  "engines": {
    "node": ">= 0.6.10"
  },
  "keywords": [
    "hsf",
    "rpc",
    "hsfcpp"
  ],
  "contributors": [
    {
      "name": "不四",
      "email": "busi.hyy@taobao.com",
      "url": "https://work.alibaba-inc.com/work/u/52624"
    },
    {
      "name": "苏千",
      "email": "suqian.yf@alipay.com",
      "url": "https://work.alibaba-inc.com/work/u/43624"
    },
    {
      "name": "诸蛰",
      "email": "zhe.zhu@alibaba-inc.com",
      "url": "https://work.alibaba-inc.com/work/u/30803"
    }
  ],
  "readme": "## node-hsf [![status](http://toast.corp.taobao.com/task/state/id/1287)](http://toast.corp.taobao.com/task/view/id/1287)\n\n淘宝 hsf 的 node 版本，实现了 provider 和 consumer 的主要功能。序列化反序列化模块通过 C++ 模块实现,网络传输部分 node 实现。\n\n同时在 hsf 的基础上扩展了 node 之间互相调用的 JSON 序列化方式，性能有极大提升。\n\n* benchmark: [benchmark](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/benchmark.md)\n* changelog: [changelog](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/changelog.md)\n\n## node-hsf v1.0\n\nnode-hsf 升级到 1.0，用纯 js 重写了整个 hsf 协议的序列化方式，不再需要编译 c++ addon, 完全支持所有的平台。\n\n * 纯 js 实现导致 node-hsf 性能降低严重，将会在之后的版本中修复，如果有高性能的服务，可以通过在外部安装 `hsf-protocol-cpp` 模块，引入 c++ addon 的 hsf 序列化包。 node-hsf 将会引用 c++ addon 序列化。\n * js 版本的协议支持传递循环引用对象，其他地方也可能会和 c++ 版本的协议稍微有出入，如果要在生产环境使用 c++ addon，而开发环境使用 js 协议，需要进行一定的测试。\n * 提供一个辅助编写 hsf 调用的参数的库: [js-to-java](https://github.com/node-modules/js-to-java)，具体的使用案例可以查看[这里](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/test/invoke_java_test.js)。\n\n使用遇到任何问题，旺旺联系@不四。\n\n## Main Feature\n\n### HSF Feature\n\n* Hessian 序列化\n* 消费者异步调用\n* 消费者调用超时设置（服务级别/方法级别）\n* 消费者路由轮询\n* 服务者服务发布\n* 服务者流量限制功能\n\n### Customize for Node\n\n* node 互相调用使用 JSON 序列化，性能比 http 高 **70%** 。benchmark: [benchmark](http://gitlab.alibaba-inc.com/node/node-hsf/blob/master/benchmark.md)\n* 服务中间件\n* client 根据服务注册信息自动选择序列化类型\n* server 通过调用信息决定序列化类型，兼容 node 与 java 用不同序列化方式调用\n\n## HSF介绍及相关文档\n\nHSF 全称为 High-Speed Service Framework，旨在为淘宝的应用提供一个分布式的服务框架。\n\n### 原理\n\n 1. HSF 服务端向 configServer 注册信息，提供服务的地址和端口号（可以多个），同时监听该端口等待客户端调用。\n 2. HSF 客户端定时向 configServer 请求指定 `服务名+版本号` 的服务端地址和端口号。\n 3. 客户端和服务端直接建立连接，通过 HSF 指定的序列化, 反序列化方法和传输协议进行 TCP 通讯。\n\n### 关于 configServer host 的配置值：\n\n* 日常: 10.232.16.8\n* 线上: commonconfig.config-host.taobao.com\n* 预发: 172.23.226.84\n\n### 相关文档\n\n * [HSF 项目说明](http://confluence.taobao.ali.com/pages/viewpage.action?pageId=819280)\n * [HSF 查询服务](http://hsf.taobao.net/hsfops/)\n\n## 安装\n\n通过内部 npm 安装：\n\n```bash\n$ npm install tnpm -g\n$ tnpm install hsf\n```\n\n## node 发布 HSF 服务\n\n```js\nvar hsf = require('hsf');\n\n/**\n * HSFServer\n * @param {Object} options\n *  - {String} configSvr, default is 'commonconfig.taobao.net'.config server的地址，根据各个环境不同地址不同\n *  - {String|Array} serviceName, default is 'com.taobao.hsfcpp.service.nodejs.demo'. 注册的服务名字\n *  - {String|Array} version, defailt is '1.0.0' 注册服务的版本\n *  - {String} group, default is 'HSF'  设置服务的分组\n *  - {Number} port, default is `12200` 监听的端口\n *  - {String|WriteStream|function} logger, log file path or log writable stream or log function.\n      日志文件路径或者stream或者记录日志的方法\n *  - {Boolean} logOff, 关闭日志, default false\n *  - {Object} forwards, forwards info  可以将hsf流量copy一份转发给其他服务用于测试\n *    - {String} to, which server address want to forwards to. example: '127.0.0.1.12201'\n *    - {Object} options\n *      - reconnectTime default 5s\n *      - delay  default 10ms\n *  - {Boolean} autoCheck, default is `false`. 如果设置为true，则会开启服务的自检，\n      会定时检查当前机器是否注册成功，每一个方法是否能够调用到\n *  - {Boolean} nohsf, default true. not only hsf， nodejs互相调用时将不使用hessian作为序列化方式。\n      不支持buffer/date，性能上有提升\n *  - {Number} timeout, regist timeout to nitify java client，注册服务的超时时间到 config server ,\n      告知 java 客户端超过多少毫秒后超时返回\n *  - {String} diamondHost, if you want to push api meta info to hsf, you need to set this.\n *      daily: \"commonconfig.taobao.net\"\n *      pre | online: \"commonconfig.config-host.taobao.com\"\n * @constructor\n */\nvar server = hsf.createServer({\n  serviceName : 'com.taobao.hsfcpp.service.nodejs',\n  version : '1.0.0',\n  port : 12201,\n  diamondHost: 'commonconfig.taobao.net'\n});\n\n// 注册一个HSF服务API,添加流量限制（方法级别和全局的接口级别。）\n// 注意第一个参数是res，包含与客户端的连接信息以及发回响应的接口send()\nfunction plus(res, a, b) {\n  console.log('客户端地址和端口：%s:%d', res.socket.remoteAddress, res.socket.remotePort);\n  console.log(a + b);\n  res.send(\"sync function in nodejs return \" + (a + b));\n}\n\nfunction time(res, a, b) {\n  console.log(a * b);\n  setTimeout(function () {\n    res.send(\"sync function in nodejs return \" + (a * b));\n  }, 100);\n}\n\nvar hsfFuncs = {\n  hsfFunc1: function (res, a, b) {\n    res.send('hsf func 1');\n  },\n  hsfFunc2: function (res, a, b) {\n    res.send('hsf func 2');\n  },\n  httpFunc: function (res, a, b) {\n    res.send('http func');\n  },\n  notFunc: 'string'\n};\n\nserver.registFunc('plus', plus)\n  .setLimiter('plus', 1000, 5000);    //流量限制1000， 峰值5000\n  .registFunc('time', time)\n  .registFunc(hsfFuncs, /^hsf/)       //将hsfFuncs对象内的所有符合条件的，且value为function的元素注册到hsf\n  .setGlobalLimiter(2000, 5000);      //全局流量限制\n\n// [可选] api meta 信息\nvar apiMeta = {\n  codeSource: 'nodejs-demo-1.0.0-SNAPSHOT.jar',\n  methods: [\n    {\n      name: 'ping2',\n      parameterTypes: [],\n      returnType: 'java.lang.String'\n    },\n    {\n      name: 'plus',\n      parameterTypes: [\n        'java.lang.Long',\n        'java.lang.Long'\n      ],\n      returnType: 'long'\n    }\n  ]\n};\n\n// 发布服务到 configServer\nserver.publish(apiMeta);\n// 开始监听指定端口\nserver.listen();\n```\n\nHSFServer会有许多事件抛出：\n\n```js\n// 当configServer挂掉，无法注册的时候，会抛出ConfigServerError事件\nserver.on('configServerError', function (err) {\n  // do something\n});\n\n// 当连接到configServer，注册服务成功的时候触发\nserver.on('CSconnect', function () {\n  // do something\n})\n\n// 当与configServer的连接断开，服务不再注册的时候触发\nserver.on('CSdisconnect', function () {\n  // do something\n})\n\n// 当hsf与客户端每次建立链接的时候触发\nserver.on('connection', function () {\n  // do something\n})\n\n// 如果开启了autoCheck,则在自检发现问题的时候会触发,通过监听这个事件，可以知道提供服务的健康情况\nserver.on('autocheck', function (msg) {\n  // do something\n})\n```\n\n如果设置了 api meta 信息, 则能查看到: [com.taobao.hsfcpp.service.nodejs.benchmark:1.0.0](http://ops.jm.taobao.net/service-manager/service_search/search.htm?key=com.taobao.hsfcpp.service.nodejs.benchmark%3A1.0.0&type=1)\n\n![1](http://nfs.nodeblog.org/9/7/970d7ccae05876eb9eb115ff3c071a43.png)\n\n### HSF中间件\n\nHSF server 提供类似 `connect` 的中间件支持。\n\n```js\n// 中间件形式类似于connect\n// res.next()继续执行， res.send()返回结果\nvar middlewares = {\n  ip: function (res) {\n    if (res.remoteAddress !== '127.0.0.1') {\n      res.send('address error');\n    }\n    res.next();\n  },\n  auth: function (res, name) {\n    if (name !== 'busi') {\n      res.send('403');\n    }\n    res.next();\n  },\n  add: function (res) {\n    res._type = 'debug';\n    res.next();\n  },\n  check: function (res, a, b) {\n    if (typeof a !== 'number' || typeof b !== 'number') {\n      return res.send('wrong type');\n    }\n    res.next();\n  }\n};\n\n// 使用中间件\nserver.registFunc('plus', plus)\n  .registFunc('asyncPlus', asyncPlus)\n  .registFunc('get', get)\n  .registFunc('update', update)\n  .registFunc('log', log)\n  .use(middlewares.ip) //所有的hsf注册函数都会经过这个中间件，或者使用use('*', middlewares.ip)\n  .use('log', middlewares.add) //指定注册的函数名称\n  .use(['get', 'update'], middlewares.auth) //数组\n  .use(/plus/i, middlewares.check) //正则\n  .listen() //中间件与注册的函数之间的对应关系将在listen的时候才创建。中间件之间是有先后顺序的，但是与registFunc先后顺序无关\n  .publish();\n```\n\n### HSFResponse\n\nHSFResponse 会作为第一个参数传递给所有的中间件以及最终的处理函数。\n\n### 字段：\n\n```js\nremoteAddress: 调用方的地址\nsocket: 与调用方之间的 socket\nserver: 属于的 hsf server\nmethod: 这次调用的是哪个方法\nstarttime: 调用开始时间\n```\n\n### Access Log Middleware\n\n自动记录 nginx 类似格式的 access log ，需要配合 [ali-logger](http://gitlab.alibaba-inc.com/edp/logger/tree/master) 使用，\n或者你的 logger 实现了 `accessLog(ip, usec, method, url, status, bytes, referer, userAgent)` 接口.\n\n使用方法:\n\n```js\nvar logger = require('ali-logger');\n// 初始化 logger\nlogger.init({\n  logdir: '/tmp/testhsflogs',\n  accessLog: true,\n});\n\n// 注册 accesslog 中间件\nserver.use(hsf.accesslog({logger: logger}));\n```\n\n## node调用HSF服务\n\n```js\nvar hsf = require('hsf');\n/**\n * create a new hsfClient\n * @param  {Object} options global config\n *  - {String} configSvr              configServer的host地址，默认为日常环境\n *  - {Number} connectTimeout         此client下全局的建立连接超时时间，默认为3秒\n *  - {Number} responseTimeout        此client下全局的响应超时时间，默认为3秒\n *  - {Number} routeInterval          此client下全局的向configSvr重新请求服务端地址、更新地址列表的间隔时间，默认为1分钟\n *  - {Boolean} snapshot              是否使用快照功能，使用快照则在启动的时候如果无法连接到config server，则读取本地缓存的服务者地址。\n *  - {String|Stream|function} logger 记录日志的路径或者Stream或者方法用于日志的写入\n *  - {Boolean} logOff                关闭日志\n *  - {Boolean} keepAlive             设置此client下生成的所有consumer是否与服务端维持长连接，默认为true\n *  - {Boolean} noDelay               设置此client下生成的所有consumer是否关闭nagle算法，默认为true\n * @return {HsfClient}\n * @public\n */\nvar client = hsf.createClient({});\n\n/**\n * 创建一个consumer，可以同时创建多个consumer来调用多个HSF服务\n * @param  {string} interface   服务接口名\n * @param  {string} version     服务版本号\n * @param  {object} options\n *  - group                     服务分组，默认为hsf分组，一般不需要更改\n *  - routeInterval             此consumer的重新请求服务端地址、更新地址列表的间隔时间\n *  - connectTimeout            此consumer的建立连接超时时间\n *  - responseTimeout           此consumer的响应超时时间\n *  - id                        interface:version，在不传这两个参数的时候可以用id来替代\n *  - keepAlive                 此consumer是否与服务器维持长连接\n *  - noDelay                   此consumer是否关闭nagle算法\n * @return {Consumer}\n * @public\n */\nvar testConsumer = client.createConsumer('com.taobao.hsfcpp.service.nodejs', '1.0.0');\n\n// 调用服务端的 plus 方法，第二个参数是调用 plus 方法时的参数数组，相当于调用 plus(3, 4);\ntestConsumer.invoke('plus', [3, 4], function (err, data) {\n  // callback\n});\n```\n\n注意：\n\n* 应用在使用 `node-hsf` 来调用其他的 hsf 服务的时候，只需要用 `var client = hsf.createClient()` 创建一个全局的 `clinet`，根据不同的环境设置全局参数以及 configsrv 等。\n* 可以通过 `var consumer = client.createConsumer()` 来创建对不同的hsf服务的调用的实例，\n然后使用 `consumer.invoke('methodName', [args], callback)` 来调用服务方提供的hsf方法。\n* `keepAlive` 选项: client 和 consumer 的初始化 options 中都有这个选项，\n可以对全局或者单个的 consumer 设置是否采用长连接方式与服务端进行连接。如果应用对接口的调用量很小的时候（可能一天只用调用几十次），\n建议设置 `keepAlive` 为 false ，当调用次数很高的时候设置 `keepAlive` 为 true ，性能上能有很大提升。默认为 `false`。\n\n### node-hsf 调用 java 服务\n\n由于 java 是强类型语言，而 HSF 的服务接口匹配规则是需要参数强制匹配的，\n所以每次调用都需要确定类型名称，不能够再像调用 node 方法一样进行远程HSF服务调用。\n因此，要调用一个 Java 的 HSF 服务，除了知道服务接口名和版本号之外，还需要知道其具体的方法以及参数。\n通过要调用的 Java 服务方提供的 `Maven Dependency` 。\n\n```xml\n <dependency>\n  <groupId>com.taobao.tcif</groupId>\n  <artifactId>tcif-lib</artifactId>\n  <version>1.0.9</version>\n</dependency>\n```\n\n可以在 [nexus 这里](http://mvnrepo.taobao.ali.com:8081/nexus/index.html#welcome) 获取到对应的 jar 包源码。\n下载解压之后可以看到 Java HSF 服务的接口以及参数信息。\n![search jar](http://gitlab.taobao.ali.com/uploads/note/attachment/848/maven.png)\n\n获取到这些信息之后，根据下面的类型映射表格，来进行对应参数的调用。\n\n#### Java 对象与 Node 的对应关系以及调用方法\n\n|Java 类型|Node 类型|调用参数表示|备注|\n|--------|--------|------------|----|\n|NullObject|null or Undefined|`null` or `Undefined`|node中的null和Undefined默认对应到Java的NullObject\n|boolean|Boolean|`{$class: 'boolean', $: true}` or `true`| |\n|Java.lang.Boolean|Boolean|`{$class: 'java.lang.Boolean', $: true}`| |\n|int|Integer|`{$class: 'int', $: 123}` or `123`|32位整型|\n|java.lang.Integer|Integer|`{$class: 'java.lang.Integer', $: 123}`|32位整型|\n|short|Integer|`{$class: 'short', $: 123}`|16位短整型，超出可能强制转换导致难以定位的bug|\n|java.lang.Short|Integer|`{$class: 'java.lang.Short', $: 123}`|16位短整型，超出可能强制转换导致难以定位的bug|\n|byte|Integer|`{$class: 'byte', $: 12}`|8位整型，超出可能强制转换导致难以定位的bug|\n|java.lang.Byte|Integer|`{$class: 'java.lang.Byte', $: 12}`|16位短整型，超出可能强制转换导致难以定位的bug|\n|long|Number|`{$class: 'long', $: 123456789}`|64位长整型，Number强制转换到int_64,超出范围可能导致难以定位的bug|\n|java.lang.Long|Number|`{$class: 'java.lang.Long', $: 123456789}`|64位长整型，Number强制转换到int_64,超出范围可能导致难以定位的bug|\n|double|Number|`{$class: 'double', $: 1.23}` or `1.23`|Node中的浮点数默认对应到Java的double|\n|java.lang.Double|Number|`{$class: 'java.lang.Double', $: 1.23}`| |\n|floeat|Number|`{$class: 'float', $: 1.23}`| |\n|java.lang.Float|Number|`{$class: 'java.lang.Float', $: 1.23}`| |\n|java.util.Date|Date|`new Date()`|node中的Date对象默认对应为java.util.Date|\n|java.lang.String|String|`{$class: 'java.lang.String', $: '123'}` or `'123'`|Node中的String默认对应到java.lang.String|\n|char|String|`{$class: 'char', $: '1'}`| |\n|char[]|String|`{$class: 'char[]', $: '123'}`| |\n|java.lang.Character|String|`{$class: 'java.lang.Character', $: '123'}`| |\n|byte[]|Buffer|`new Buffer('abc', 'utf-8');`|Node中utf8编码的Buffer默认对应到Java中的byte[]|\n|ArrayList|Array|`{$class: 'java.util.ArrayList', $: [1, 2, 3]}` or `[1, 2, 3]`|Node中的Array默认对应到Java中的java.util.ArrayList|\n|java.util.List|Array|`{$class: 'java.util.List', $: [1, 2, 3]}`| |\n|java.util.Set|Array|`{$class: 'java.util.Set', $: [1, 2, 3]}`| |\n|java.util.Iterator|Array|`{$class: 'java.util.Iterator', $: [1, 2, 3]}`| |\n|java.util.Enumeration|Array|`{$class: 'java.util.Enumeration', $: [1, 2, 3]}`| |\n|java.util.HashMap|Object|`{$class: 'java.util.HashMap', $: {a: 1}}` or `{a: 1}`|Node中的Object默认对应到Java中的java.util.HashMap|\n|java.util.Map|Object|`{$class: 'java.util.Map', $: {a: 1}}`|java.util.Map的key可以是任意类型，但是ndoe中的Object的key只能是string，此处待解决|\n|java.util.Dictionary|Object|`{$class: 'java.util.Dictionary', $: {a: 1}}`| |\n|com.taobao.testDO|Object|`{$class: 'com.taobao.testDO', $: {a: 1, b: {$class: 'long', $: 123456789}}}`|Java自定义对象形式|\n\n#### Java 数组与 Node 的对应关系以及调用方法\n\n|Java类型|Node类型|调用方法|\n|--------|--------|------------|----|\n|boolean[]|Array|`{$class: '[boolean', $: [true, false]}`|\n|short[]|Array|`{$class: '[short', $: [1, 2]}`|\n|int[]|Array|`{$class: '[int', $: [1, 2]}`|\n|long[]|Array|`{$class: '[long', $: [1, 2]}`|\n|float[]|Array|`{$class: '[float', $: [1.1, 2.2]}`|\n|double[]|Array|`{$class: '[double', $: [1.1, 2.2]}`|\n|Integer[]|Array|`{$class: '[java.lang.Integer', $: [1, 2]}`|\n|Long[]|Array|`{$class: '[java.lang.Long', $: [1, 2]}`|\n|String[]|Array|`{$class: '[string', $: ['1', '2']}`|\n|Object[]|Array|`{$class: '[object', $: [{a: 1} ,{a: 2}]}`|\n|XxxYyy[]|Array|`{$class: '[aaa.bbb.XxxYyy', $: [{a: 1}, {a: 2}]}`|\n\n#### 注意事项\n\n* 建议通过[js-to-java](https://github.com/node-modules/js-to-java) 来辅助编写 java 对象。\n* 不支持key类型非`String`的对象。\n* 调用Java自定义类型的时候，必须有完整的包名，`com.taobao.uic.common.domain.BaseDeliverAddressDO`。\n* 如果不使用`{$class: 'name', $: value}`的形式传递参数，则按照默认的node向java对象映射进行调用。\n* 当调用的java方法接受的参数是抽象类，而实际传递的参数需要是这个抽象类的子类的时候，例如HSF的服务方法为：\n\n```java\nvoid foo(AbstractClass obj);\n```\n\n`AbstractClass` 是抽象类，实际序列化传入的对象是它的子类：`ConcreteSubClass`。\n那么此时在进行 HSF 调用时，一方面需要指定 `AbstractClass` 作为参数类型以让 HSF 能找到对应的方法，\n另一方面又需要指定 `ConcreteSubClass` 使反序列化时能正确实例化对象。所以，需要多传递一个参数`$abstractClass`：\n\n```js\n{\n  $class: 'com.taobao.ConcreteSubClass',       //子类名\n  $abstractClass: 'com.taobao.AbstractClass',  //抽象父类名\n  $: {a: 1, b: 'string'}\n}\n```\n\n* 当需要传递 `java.lang.StringBuilder` 的 java 对象时，可以这样构造：\n\n```java\nStringBuilder str = 'StringBuilder';\n```\n\n=>\n\n```js\nvar str = 'StringBuilder';\n{\n  $class: 'java.lang.StringBuilder',\n  $: {\n    value: {\n      $class: '[char',\n      $: str\n    },\n    count: str.length\n  }\n}\n```\n\n* 当需要传递 `java.util.Enumeration` 枚举类型的时候\n\n```java\npublic enum RiskLevel {\n  H,\n  M,\n  L\n};\n```\n\n=>\n\n```js\n{\n  $class: 'com.alibaba-buc.api.param.RiskLevel',\n  $: {name: 'L'}\n}\n```\n\n#### 调用实例\n\n```js\nvar hsf = require('hsf');\nvar client = hsf.createClient({\n  configSvr: '10.232.16.8'\n});\nvar UicDeliverAddressService = client.createConsumer('com.taobao.uic.common.service.userinfo.UicDeliverAddressService',\n  '1.0.0.daily');\nvar baseDeliverAddressDO = {\n  $class: 'com.taobao.uic.common.domain.BaseDeliverAddressDO',\n  $: {\n    id: 13254,\n    idLong: {\n      $class: 'long',\n      $: 13254\n    },\n    fullName: 'gongyangyu',\n    phone: '123456789',\n    mobile: '123456789',\n    address: 'chuangyedasha',\n    postCode: '310018',\n    userId: {\n      $class: 'long',\n      $: 24567\n    },\n    status: 1,\n    city: 'hangzhou',\n    province: 'zhejiang',\n    area: 'xihu',\n    devisionCode: 'abcde',\n    'addressDetail': 'huaxinlu99hao'\n  }\n};\nvar args = [baseDeliverAddressDO, 'gongyangyutest'];\nUicDeliverAddressService.invoke('insertDeliverAddr', args, function(err, data) {\n  console.log(err, data);\n});\n```\n\n更多调用示例，查看 `test/invoke_java_test.js` 文件。\n\n## node-hsf 性能测试工具\n\n在 node-hsf 中提供了一个 hsf 服务的性能测试工具，可以通过这个小工具对自己的 server 进行性能测试。\n\n```bash\nbenchmark [options]\nexample:./benchmark -i com.taobao.hsfcpp.service.nodejs.benchmark -v 1.0.0 -f plus -a [1,2] -n 20000 -c 50\n\nOptions:\n  -n, --request     总请求数                                          [default: 100]\n  -c, --concurrent  并发数                                           [default: 1]\n  -s, --configsvr   config server地址                               [default: \"commonconfig.taobao.net\"]\n  -i, --interface   服务提供者的接口名\n  -v, --version     服务提供者的版本号\n  -f, --function    调用方法名\n  -a, --arguments   调用参数数组\n  -t, --timeout     调用方法的超时时间\n  -r, --result      预期结果值\n  -l, --log         -l FILE, LOG to FILE.\n  -T, --logType     log type, could be markdown/md, default text\n  -C, --config      输入的json格式的config文件地址，包含测试参数，输出结果\n```\n\n## 注意事项\n\n1. node 版本的 HSF 支持的数据结构：Number, String, Bool, Null, Undefined，Array，Object，Date，Buffer，不支持循环引用\n2. 之前 HSF 客户端在 createConsumer 的时候，默认情况下如果以 `.daily` 结尾，则会自动设置分组为 `DAILYGROUP` 。\n现在 HSF 更新之后，不再会自动设置到 `DAILYGROUP` ，将全部设置为 `HSF` 分组。\n3. node-hsf 发布服务的时候，也不再会根据版本号自动选择分组，全部都默认设置为 `HSF` 分组，如果需要设置到 `DAILYGROUP` ，\n请在创建服务的时候加入 `group` 参数来指定。\n\n### 联系\n\n如果有任何问题，请咨询[@不四](http://work.alibaba-inc.com/work/u/52624), @苏千.\n\n### Authors\n\n```bash\n$ git summary\n\n project  : node-hsf\n repo age : 1 year, 3 months\n active   : 98 days\n commits  : 337\n files    : 71\n authors  :\n   222  不四                  65.9%\n    70  苏千                  20.8%\n    23  dead-horse              6.8%\n    18  heyiyu.pt               5.3%\n     4  ????                    1.2%\n```\n",
  "readmeFilename": "README.md",
  "_id": "hsf@1.0.0-beta9",
  "_from": "hsf@~1.0.0-beta9"
}
