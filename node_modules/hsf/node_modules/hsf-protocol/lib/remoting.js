/**!
 * hsf-protocal - lib/remoting.js
 * Copyright(c) 2014 Alibaba Group Holding Limited.
 *
 * Authors:
 *   busi.hyy <busi.hyy@taobao.com>
 */

var hessian = require('hessian.js');
var debug = require('debug')('hsf-protocal:remoting');
var hsfHessian = require('./hessian');
var constant = require('./constant');

/**
 * packet
 *   - {Number} type  req/res
 *   - {Number} packetId    uniq packet id
 *   - {Object} data  real object data
 * @return {Buffer}
 */
exports.encode = function (packet) {
  var head = new Buffer(14);
  head.fill(0);
  head[0] = 0x0d; //protocol version
  head[1] = packet.type === 'res' ? 0x01 : 0x00;  // req=0/res=1
  head[2] = 0x01; // hessian
  head[3] = packet.type === 'res' ? 0x00 : 0x02;
  var handler = getEncodeHandler(packet.type);
  // gen buf
  var connBuf = handler.conn(packet.packetId);
  var appBuf = handler.app(packet.data);

  //write head
  head.writeUInt32BE(connBuf.length, 5);
  head.writeUInt8(handler.encodeClassnameBuf.length, 9);
  head.writeUInt32BE(appBuf.length, 10);

  debug('gen the remoting buffer with connBuf length %d, appBuf length %d',
    connBuf.length, appBuf.length);

  //head + connect buffer + classname + app buffer
  return Buffer.concat([head, connBuf, handler.encodeClassnameBuf, appBuf]);
};

exports.decode = function (type, buf) {
  if (buf.length <= 14) {
    // size must bigger than 14
    debug('decode buffer error, buffer length is %d', buf.length);
    return null;
  }

  // parse head
  var version = buf[0];
  var headerType = buf[1];
  if (version !== 0xD || (headerType !== 0x0 && headerType !== 0x1)) {
    // head error
    debug('decode buffer head version or type error');
    return null;
  }

  var connLen = buf.readUInt32BE(5);
  var appClassnameLen = buf.readUInt8(9);
  var appLen = buf.readUInt32BE(10);

  var packetSize = 14 + connLen + appClassnameLen + appLen;

  if (packetSize > 5 * 1024 * 1024) {
    // too big
    debug('packet size %d is bigger than 5M', packetSize);
    return null;
  }
  if (buf.length < packetSize) {
    // too small
    debug('buffer size %d is smaller than packet size %d', buf.length, packetSize);
    return null;
  }

  var handler = getDecodeHandler(type);

  // decode connection buffer
  var connBuf = buf.slice(14, 14 + connLen);

  var connInfo = {};
  connInfo = handler.conn(connBuf);

  if (connInfo.errorMsg) {
    // error message just throw
    throw new Error(connInfo.errorMsg);
  }

  var appClassname = buf.slice(14 + connLen, 14 + connLen + appClassnameLen)
    .toString();
  var appBuf = buf.slice(14 + connLen + appClassnameLen, packetSize);
  var appInfo = {};
  var bufType = 'HSF';

  switch (appClassname) {
  case handler.decodeClassname:
    try {
      appInfo = handler.app(appBuf);
    } catch (err) {
      throw new Error('fail to decode app object: ' + err.message);
    }
    break;
  case 'java.lang.Byte':
    bufType = 'HEARTBEAT';
    break;  // ignore 一个 byte 的心跳响应
  case constant.CONNECTION_HEART_BEAT_CLASSNAME:
    bufType = 'HEARTBEAT';
    break;
  default:
    throw new Error('the app object is invalid');
  }

  var out = {
    packetId: connInfo.packetId,
    type: bufType,
    app: appInfo
  };
  return out;
};

function getEncodeHandler(type) {
  var handler = {};
  switch (type) {
  case 'req':
    return {
      conn: hsfHessian.encodeRequestConn,
      app: hsfHessian.encodeRequest,
      encodeClassnameBuf: constant.HSF_REQUEST_CLASSNAME_BUF,
    };
  case 'res':
    return {
      conn: hsfHessian.encodeResponseConn,
      app: hsfHessian.encodeResponse,
      encodeClassnameBuf: constant.HSF_RESPONSE_CLASSNAME_BUF
    };
  case 'heartbeat':
    return {
      conn: hsfHessian.encodeRequestConn,
      app: hsfHessian.encodeHeartBeat,
      encodeClassnameBuf: constant.CONNECTION_HEART_BEAT_CLASSNAME_BUF
    };
  case 'cs':
    return {
      conn: hsfHessian.encodeRequestConn,
      app: hsfHessian.encodeCsRequest,
      encodeClassnameBuf: constant.CS_PROTOCOL_CLASSNAME_BUF
    };
  }
}

function getDecodeHandler(type) {
  var handler = {};
  switch (type) {
  case 'req':
    return {
      conn: hsfHessian.decodeRequestConn,
      app: hsfHessian.decodeRequest,
      decodeClassname: constant.HSF_REQUEST_CLASSNAME
    };
  case 'res':
    return {
      conn: hsfHessian.decodeResponseConn,
      app: hsfHessian.decodeResponse,
      decodeClassname: constant.HSF_RESPONSE_CLASSNAME
    };
  }
}
