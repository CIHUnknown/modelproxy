/**!
 * hsf-protocol - lib/utils.js
 * Copyright(c) 2014 Alibaba Group Holding Limited.
 *
 * Authors:
 *   busi.hyy <busi.hyy@taobao.com>
 */

var is = require('is-type-of');
var constant = require('./constant');

var DEFAULT_CLASSNAME = constant.DEFAULT_CLASSNAME;

var has = exports.has = function (val, prop) {
  return Object.prototype.hasOwnProperty.call(val, prop);
};

/**
 * auto detect a val to a java type
 * if val.$class was set, return val.$class
 * @param {Object} val
 * @return {String}
 */
exports.getJavaClassname = function (val) {
  if (is.nullOrUndefined(val) || is.NaN(val)) {
    return DEFAULT_CLASSNAME.null;
  }

  var type = typeof val;
  switch (type) {
  case 'boolean':
    return DEFAULT_CLASSNAME.boolean;
  case 'string':
    return DEFAULT_CLASSNAME.string;
  case 'number':
    if (is.long(val)) {
      return DEFAULT_CLASSNAME.long;
    }
    if (is.int) {
      return DEFAULT_CLASSNAME.int;
    }
    return DEFAULT_CLASSNAME.double;
  }

  if (is.date(val)) {
    return DEFAULT_CLASSNAME.date;
  }
  if (is.buffer(val)) {
    return DEFAULT_CLASSNAME.byteArray;
  }
  if (is.array(val)) {
    return DEFAULT_CLASSNAME.list;
  }
  if (is.error(val)) {
    return DEFAULT_CLASSNAME.exception;
  }

  if (!has(val, '$class') || !has(val, '$')) {
    return DEFAULT_CLASSNAME.map;
  }

  if (has(val, '$abstractClass')) {
    return val.$abstractClass;
  }
  if (val.$class[0] === '[') {
    return parseList(val.$class);
  }
  return val.$class;
};

function  parseList(name) {
  switch (name) {
  case '[short':
    return '[S';
  case '[int':
    return '[I';
  case '[boolean':
    return '[Z';
  case '[double':
    return '[D';
  case '[long':
    return '[J';
  case 'float':
    return '[F';
  case '[string':
    return '[Ljava.lang.String;';
  case '[object':
    return '[Ljava.lang.Object;';
  default:
    return '[L' + name.slice(1) + ';';
  }
}

exports.writePacketId = function (buf, value, pos) {
  if (value < constant.MAX_INT_32) {
    buf.writeUInt32BE(value, pos + 4);
  } else {
    buf.writeUInt32BE((value / (constant.MAX_INT_32 + 1)) | 0, pos);
    buf.writeUInt32BE((value % (constant.MAX_INT_32 + 1)) | 0, pos + 4);
  }
};
