{
  "name": "hessian.js",
  "version": "0.1.10",
  "description": "Hessian Serialization written by pure JavaScript, support all kind of types in Java.",
  "main": "index.js",
  "scripts": {
    "test": "make test-all"
  },
  "config": {
    "blanket": {
      "pattern": "//^((?!(node_modules|test|common)).)*$/"
    },
    "travis-cov": {
      "threshold": 95
    }
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/dead-horse/hessian.js.git"
  },
  "keywords": [
    "hessian",
    "protocol",
    "java",
    "rpc",
    "serialization"
  ],
  "author": {
    "name": "dead_horse",
    "email": "dead_horse@qq.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/dead-horse/hessian.js/issues",
    "email": "dead_horse@qq.com"
  },
  "homepage": "https://github.com/dead-horse/hessian.js",
  "dependencies": {
    "byte": "0.2.1",
    "debug": "0.7.4",
    "is-type-of": "0.1.0"
  },
  "devDependencies": {
    "js-to-java": "~0.0.2",
    "autod": "~0.0.13",
    "blanket": ">=1.1.6",
    "contributors": "*",
    "coveralls": "*",
    "mocha": "*",
    "mocha-lcov-reporter": "*",
    "should": "3.1.3",
    "travis-cov": "*"
  },
  "contributors": [
    {
      "name": "dead-horse",
      "email": "dead_horse@qq.com",
      "url": "https://github.com/dead-horse"
    },
    {
      "name": "fengmk2",
      "email": "fengmk2@gmail.com",
      "url": "https://github.com/fengmk2"
    }
  ],
  "readme": "hessian.js [![Build Status](https://secure.travis-ci.org/dead-horse/hessian.js.png)](http://travis-ci.org/dead-horse/hessian.js) [![Coverage Status](https://coveralls.io/repos/dead-horse/hessian.js/badge.png)](https://coveralls.io/r/dead-horse/hessian.js) [![Dependency Status](https://gemnasium.com/dead-horse/hessian.js.png)](https://gemnasium.com/dead-horse/hessian.js) [![NPM version](https://badge.fury.io/js/hessian.js.png)](http://badge.fury.io/js/hessian.js)\n=========\n\nHessian Serialization [1.0](http://hessian.caucho.com/doc/hessian-1.0-spec.xtp) and [2.0](http://hessian.caucho.com/doc/hessian-serialization.html) written by pure JavaScript.\nSupport all kind of types in Java.\n\n## Install\n\n[![NPM](https://nodei.co/npm/hessian.js.png?downloads=true)](https://nodei.co/npm/hessian.js/)\n\n## Support Types\n\n8 primitive types:\n\n1. raw binary data\n2. boolean\n3. 64-bit millisecond date\n4. 64-bit double\n5. 32-bit int\n6. 64-bit long\n7. null\n8. UTF8-encoded string\n\n3 recursive types:\n\n1. `list` for lists and arrays\n2. `map` for maps and dictionaries\n3. `object` for objects\n\none special contruct:\n\n1. ref for shared and circular object references\n\nHessian 2.0 has 3 internal reference maps:\n\n* An object/list reference map.\n* An class definition reference map.\n* A type (class name) reference map.\n\n## Encoder\n\nTips: you can use with [js-to-java](https://github.com/dead-horse/js-to-java) to help you write java class in js.\n\n### Simple javascript type\n\n```js\nvar hessian = require('hessian.js');\nvar java = require('js-to-java');\nvar encoder = new hessian.Encoder();\n\nencoder.write(1); // int\nencoder.write(1.1); // double\nencoder.write(1e100); // double\nencoder.write(Math.pow(2, 18)); // long\nencoder.write(true); // boolean\nencoder.write(null); // null\nencoder.write('test'); // string\n\n// java base types\nencoder.write(java.long(3001010320)); // 3001010320L\nencoder.write(java.double(100)); // double\nencoder.write(java.array.int([0, 1, 2])); // int[] = {0, 1, 2}\n\nvar object = {};\nobject.prop1 = [1, 2, 3];\nobject.prop2 = 'string';\nobject.prop3 = {key: 'value'};\nobject.prop4 = object;  // circular\nencoder.write(object); // object\n```\n\n### Complex java type\n\n```js\nvar hessian = require('hessian.js');\nvar encoder = new hessian.Encoder();\n\nvar long = {\n  $class: 'java.lang.Long',\n  $: 1\n}\nencoder.write(long); // long type\n\nvar testObject = {\n  $class: 'com.hessian.TestObject',\n  $: {\n    a: 1,\n    b: 'test',\n    c: {$class: 'java.lang.Long', $: 123}\n  }\n};\nencoder.write(testObject);\n```\n\n## Decoder\n\n```js\nvar hessian = require('hessian.js');\nvar decoder = new hessian.Decoder(buf);\n\ndecoder.read(); //return what it is\ndecoder.readNull();\ndecoder.readBool();\ndecoder.readInt();\ndecoder.readLong();\ndecoder.readDouble();\ndecoder.readDate();\ndecoder.readObect();\ndecoder.readMap();\ndecoder.readArray();\ndecoder.readList();\ndecoder.readRef();\n```\n\n## Simple Usage\n\nhessian 1.0:\n\n```js\nvar hessian = require('hessian.js');\n\nvar testObject = {\n  a: 1,\n  b: 'string',\n  c: true,\n  d: 1.1,\n  e: Math.pow(2, 40),\n  f: [1, 2, 3, '4', true, 5],\n  g: {a: 1, b: true, c: 'string'}\n};\n\nvar buf;\ntry {\n  buf = hessian.encode(testObject);\n} catch (err) {\n  console.log('encode error: ', err.message);\n  process.exit(1);\n}\n\ntry {\n  var res = hessian.decode(buf);\n  // res.should.eql(testObject);\n} catch (err) {\n  console.log('decode error: ', err.message);\n}\n```\n\nhessian 2.0:\n\n```js\nvar hessian = require('hessian.js');\n\nvar testObject = {\n  a: 1,\n  b: 'string',\n  c: true,\n  d: 1.1,\n  e: Math.pow(2, 40),\n  f: [1, 2, 3, '4', true, 5],\n  g: {a: 1, b: true, c: 'string'}\n};\n\nvar buf;\ntry {\n  buf = hessian.encode(testObject, '2.0');\n} catch (err) {\n  console.log('encode error: ', err.message);\n  process.exit(1);\n}\n\ntry {\n  var res = hessian.decode(buf, '2.0');\n  // res.should.eql(testObject);\n} catch (err) {\n  console.log('decode error: ', err.message);\n}\n```\n\n## TODO\n\n1. more unit test, include test with other language.\n2. benchmark test.\n3. ~~hessian 2.0 decode~~\n3. ~~hessian 2.0 encode~~\n\n## What's different between hassian 1.0 and 2.0?\n\n* `R` meaning `ref` on 1.0, but `x52 ('R')` represents any non-final string chunk on 2.0\n\n## Hessian 2.0 Serialization Grammar\n\n```\n           # starting production\ntop        ::= value\n\n           # 8-bit binary data split into 64k chunks\nbinary     ::= x41 b1 b0 <binary-data> binary # non-final chunk\n           ::= 'B' b1 b0 <binary-data>        # final chunk\n           ::= [x20-x2f] <binary-data>        # binary data of\n                                                 #  length 0-15\n           ::= [x34-x37] <binary-data>        # binary data of\n                                                 #  length 0-1023\n\n           # boolean true/false\nboolean    ::= 'T'\n           ::= 'F'\n\n           # definition for an object (compact map)\nclass-def  ::= 'C' string int string*\n\n           # time in UTC encoded as 64-bit long milliseconds since\n           #  epoch\ndate       ::= x4a b7 b6 b5 b4 b3 b2 b1 b0\n           ::= x4b b3 b2 b1 b0       # minutes since epoch\n\n           # 64-bit IEEE double\ndouble     ::= 'D' b7 b6 b5 b4 b3 b2 b1 b0\n           ::= x5b                   # 0.0\n           ::= x5c                   # 1.0\n           ::= x5d b0                # byte cast to double\n                                     #  (-128.0 to 127.0)\n           ::= x5e b1 b0             # short cast to double\n           ::= x5f b3 b2 b1 b0       # 32-bit float cast to double\n\n           # 32-bit signed integer\nint        ::= 'I' b3 b2 b1 b0\n           ::= [x80-xbf]             # -x10 to x3f\n           ::= [xc0-xcf] b0          # -x800 to x7ff\n           ::= [xd0-xd7] b1 b0       # -x40000 to x3ffff\n\n           # list/vector\nlist       ::= x55 type value* 'Z'   # variable-length list\n           ::= 'V' type int value*   # fixed-length list\n           ::= x57 value* 'Z'        # variable-length untyped list\n           ::= x58 int value*        # fixed-length untyped list\n           ::= [x70-77] type value*  # fixed-length typed list\n           ::= [x78-7f] value*       # fixed-length untyped list\n\n           # 64-bit signed long integer\nlong       ::= 'L' b7 b6 b5 b4 b3 b2 b1 b0\n           ::= [xd8-xef]             # -x08 to x0f\n           ::= [xf0-xff] b0          # -x800 to x7ff\n           ::= [x38-x3f] b1 b0       # -x40000 to x3ffff\n           ::= x59 b3 b2 b1 b0       # 32-bit integer cast to long\n\n           # map/object\nmap        ::= 'M' type (value value)* 'Z'  # key, value map pairs\n           ::= 'H' (value value)* 'Z'       # untyped key, value\n\n           # null value\nnull       ::= 'N'\n\n           # Object instance\nobject     ::= 'O' int value*\n           ::= [x60-x6f] value*\n\n           # value reference (e.g. circular trees and graphs)\nref        ::= x51 int            # reference to nth map/list/object\n\n           # UTF-8 encoded character string split into 64k chunks\nstring     ::= x52 b1 b0 <utf8-data> string  # non-final chunk\n           ::= 'S' b1 b0 <utf8-data>         # string of length\n                                             #  0-65535\n           ::= [x00-x1f] <utf8-data>         # string of length\n                                             #  0-31\n           ::= [x30-x34] <utf8-data>         # string of length\n                                             #  0-1023\n\n           # map/list types for OO languages\ntype       ::= string                        # type name\n           ::= int                           # type reference\n\n           # main production\nvalue      ::= null\n           ::= binary\n           ::= boolean\n           ::= class-def value\n           ::= date\n           ::= double\n           ::= int\n           ::= list\n           ::= long\n           ::= map\n           ::= object\n           ::= ref\n           ::= string\n```\n\n## Hessian 2.0 Bytecode map\n\nHessian 2.0 is organized as a bytecode protocol.\nA Hessian reader is essentially a switch statement on the initial octet.\n\n```\nx00 - x1f    # utf-8 string length 0-32\nx20 - x2f    # binary data length 0-16\nx30 - x33    # utf-8 string length 0-1023\nx34 - x37    # binary data length 0-1023\nx38 - x3f    # three-octet compact long (-x40000 to x3ffff)\nx40          # reserved (expansion/escape)\nx41          # 8-bit binary data non-final chunk ('A')\nx42          # 8-bit binary data final chunk ('B')\nx43          # object type definition ('C')\nx44          # 64-bit IEEE encoded double ('D')\nx45          # reserved\nx46          # boolean false ('F')\nx47          # reserved\nx48          # untyped map ('H')\nx49          # 32-bit signed integer ('I')\nx4a          # 64-bit UTC millisecond date\nx4b          # 32-bit UTC minute date\nx4c          # 64-bit signed long integer ('L')\nx4d          # map with type ('M')\nx4e          # null ('N')\nx4f          # object instance ('O')\nx50          # reserved\nx51          # reference to map/list/object - integer ('Q')\nx52          # utf-8 string non-final chunk ('R')\nx53          # utf-8 string final chunk ('S')\nx54          # boolean true ('T')\nx55          # variable-length list/vector ('U')\nx56          # fixed-length list/vector ('V')\nx57          # variable-length untyped list/vector ('W')\nx58          # fixed-length untyped list/vector ('X')\nx59          # long encoded as 32-bit int ('Y')\nx5a          # list/map terminator ('Z')\nx5b          # double 0.0\nx5c          # double 1.0\nx5d          # double represented as byte (-128.0 to 127.0)\nx5e          # double represented as short (-32768.0 to 327676.0)\nx5f          # double represented as float\nx60 - x6f    # object with direct type (` ... n, o)\nx70 - x77    # fixed list with direct length (p, q, r, s, t, u, v, w)\nx78 - x7f    # fixed untyped list with direct length (x, y, z, {, |, }, ~, .....)\nx80 - xbf    # one-octet compact int (-x10 to x3f, x90 is 0)\nxc0 - xcf    # two-octet compact int (-x800 to x7ff)\nxd0 - xd7    # three-octet compact int (-x40000 to x3ffff)\nxd8 - xef    # one-octet compact long (-x8 to xf, xe0 is 0)\nxf0 - xff    # two-octet compact long (-x800 to x7ff, xf8 is 0)\n```\n\n## Authors\n\n```\n$ git summary\n\n project  : hessian.js\n repo age : 4 weeks ago\n commits  : 51\n active   : 18 days\n files    : 33\n authors  :\n    36  dead_horse              70.6%\n    15  fengmk2                 29.4%\n```\n\n## Licences\n(The MIT License)\n\nCopyright (c) 2014 dead-horse and other contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "hessian.js@0.1.10",
  "_from": "hessian.js@0.1.10"
}
