/*!
 * diamond-client - lib/client.js
 *
 * Copyright(c) 2013 - 2014 Alibaba Group Holding Limited.
 *
 * Authors:
 *   苏千 <suqian.yf@taobao.com> (http://fengmk2.github.com)
 */

"use strict";

/**
 * Module dependencies.
 */

var debug = require('debug')('diamond-client');
var EventEmitter = require('events').EventEmitter;
var urllib = require('urllib');
var mkdirp = require('mkdirp');

var VERSION = 'nodejs-diamond-client/' + require('../package.json').version;

/**
 * Diamond Client.
 *
 * @param {Object} options
 *  - {String} [host] server host and port, default is "commonconfig.taobao.net:8080"
 *  - {Number} [refreshInterval] data refresh interval time, default is 30000 ms
 *  - {String} [cacheDir] data cache dir, default is "/tmp/nodejs-diamond-client-cache"
 *  - {Number} [requestTimeout] diamond request timeout, default is 5000 ms
 */
function DiamondClient(options) {
  options = options || {};
  this._host = options.host || 'commonconfig.taobao.net:8080';
  this._updateServersURL = 'http://' + this._host + '/diamond-server/diamond';
  this._refreshInterval = options.refreshInterval || 30000;
  this._cacheDir = options.cacheDir || '/tmp/nodejs-diamond-client-cache';
  this._requestTimeout = options.requestTimeout || 5000;
  mkdirp.sync(this._cacheDir);

  this._data = {}; // key: {md5: $md5, content: $content}
  this._watches = {};
  this._timeoutHosts = {}; // host: timstamp
  this._ready = false;
  this._events = new EventEmitter();
  this._serverHosts = [];
  this._serverHostsIndex = 0;

  this._init();
}

DiamondClient.create = function (options) {
  return new DiamondClient(options);
};

DiamondClient.prototype._request = function (method, url, data, callback) {
  if (typeof data === 'function') {
    callback = data;
    data = null;
  }

  urllib.request(url, {
    method: method,
    data: data,
    timeout: this._requestTimeout,
    headers: {
      'Client-Version': VERSION
    }
  }, function (err, data, res) {
    if (err) {
      err.name = 'Diamond' + err.name;
      err.body = data && data.toString();
      err.url = method + ' ' + url;
      err.data = data;
      return callback(err, data, res);
    }
    var statusCode = res && res.statusCode || -1;
    if (statusCode !== 200) {
      err = new Error('Diamond Server Error Status: ' + statusCode);
      err.name = 'DiamondServerResponseError';
      err.body = data && data.toString();
      err.url = method + ' ' + url;
      err.data = data;
      return callback(err, data, res);
    }

    callback(null, data.toString(), res);
  });
};

DiamondClient.prototype._init = function () {
  var self = this;
  debug('_init update servers');
  self._updateServers(function (err, hosts) {
    if (err) {
      debug('_init update servers error: %s', err);
      self._events.emit('initError', err);
      // try again after 2 seconds
      setTimeout(function () {
        self._init();
      }, 2000);
      return;
    }

    debug('_init success, got %j', hosts);
    self._serverHosts = hosts;
    self._startSyncServers();
    self._startSyncConfigs();
    self._ready = true;
    self._events.emit('ready');
  });
};

DiamondClient.prototype._updateServers = function (callback) {
  var self = this;
  self._request('GET', self._updateServersURL, function (err, content) {
    if (err) {
      return callback(err);
    }
    var hosts = content.split('\n');
    var needs = [];
    for (var i = 0; i < hosts.length; i++) {
      var h = hosts[i].trim();
      if (!h) {
        continue;
      }
      var lastTimeout = self._timeoutHosts[h];
      // 上次超时在 10 分钟内的, 不使用此 host
      if (lastTimeout && (Date.now() - lastTimeout) < 600000) {
        continue;
      }
      needs.push(h);
    }

    if (needs.length === 0) {
      err = new Error('Diamond return empty hosts');
      err.name = 'DiamondServerHostEmptyError';
    }
    callback(err, needs);
  });
};

DiamondClient.prototype._syncServers = function () {
  debug('update servers start...');
  var self = this;
  self._updateServers(function (err, hosts) {
    if (err) {
      debug('update servers error: %s', err);
      return self._events.emit('updateServersError', err);
    }
    debug('update servers success, got %j', hosts);
    if (hosts && hosts.length > 0) {
      self._serverHosts = hosts;
    }
    self._events.emit('updateServers', hosts);
  });
};

DiamondClient.prototype._startSyncServers = function () {
  this._syncServersTimer = setInterval(this._syncServers.bind(this), this._refreshInterval);
};

DiamondClient.prototype._syncConfigs = function () {
  var self = this;
  var keys = Object.keys(self._watches);
  debug('start sync %j configs', keys);
  var getConfig = function (key, dataId, group, retry) {
    self._getConfig(dataId, group, function (err, content, res) {
      if (err) {
        err.dataId = dataId;
        err.group = group;
        debug('got %s config error: %s', key, err);
        if (!self._data[key]) {
          debug('try again to read %s config after 1 second', key);
          setTimeout(getConfig.bind(null, key, dataId, group, true), 1000);
        }
        return self._events.emit('syncConfigError', err);
      }

      var md5 = res.headers['content-md5'];
      var last = self._data[key];
      debug('got %s config %s, md5: %s, headers: %j', key, content, md5, res.headers);
      // make sure content is not empty
      if (content.length > 0 && (!last || last.md5 !== md5)) {
        debug('%s config updated', key);
        // first got or change
        self._data[key] = {md5: md5, content: content};
        self._events.emit(key, content);
      }
    });
  };

  keys.forEach(function (key) {
    var items = key.split(':');
    getConfig(key, items[0], items[1], false);
  });
};

DiamondClient.prototype._startSyncConfigs = function () {
  this._syncConfigsTimer = setInterval(this._syncConfigs.bind(this), this._refreshInterval);
  this._syncConfigs();
};

DiamondClient.prototype._getConfig = function (dataId, group, callback) {
  var self = this;
  if (self._serverHostsIndex >= self._serverHosts.length) {
    self._serverHostsIndex = 0;
  }
  var host = self._serverHosts[self._serverHostsIndex++];
  var url = 'http://' + host + ':8080/diamond-server/config.co';
  self._request('GET', url, {dataId: dataId, group: group}, function (err, content, res) {
    if (err) {
      if (err.code === 'ECONNREFUSED' || err.name === 'DiamondConnectionTimeoutError') {
        // remove the timeout server host
        if (self._serverHosts.length > 1) {
          var index = self._serverHosts.indexOf(host);
          if (index !== -1) {
            self._serverHosts.splice(index, 1);
            self._serverHostsIndex = 0;
            self._timeoutHosts[host] = Date.now();
          }
          debug('#%s:%s connection %s, remove it, left: %j',
            index, host,
            err.code || err.name,
            self._serverHosts);
        }
      }
    }
    callback(err, content, res);
  });
};

DiamondClient.prototype.close = function () {
  if (this._syncConfigsTimer) {
    clearInterval(this._syncConfigsTimer);
    this._syncConfigsTimer = null;
  }
  if (this._syncServersTimer) {
    clearInterval(this._syncServersTimer);
    this._syncServersTimer = null;
  }
  for (var key in this._watches) {
    delete this._watches[key];
    this._events.removeAllListeners(key);
  }
  return this;
};

DiamondClient.prototype.onError = function (name, listener) {
  this._events.on(name, listener);
  return this;
};

DiamondClient.prototype.onceError = function (name, listener) {
  this._events.once(name, listener);
  return this;
};

/**
 * Listen content
 *
 * @param {String} dataId
 * @param {String} group
 * @param {Function(content)} listener
 */
DiamondClient.prototype.on = function (dataId, group, listener) {
  var key = dataId + ':' + group;
  var exists = this._watches[key];
  this._watches[key] = true;
  this._events.on(key, listener);

  var item = this._data[key];
  if (item !== undefined) {
    process.nextTick(function () {
      listener(item.content);
    });
  } else if (!exists) {
    // sync immediately
    this._ready && this._syncConfigs();
  }
  return this;
};

DiamondClient.prototype.removeAllListeners = function (dataId, group) {
  var key = dataId + ':' + group;
  delete this._watches[key];
  this._events.removeAllListeners(key);
  return this;
};

DiamondClient.prototype.ready = function (callback) {
  if (this._ready) {
    callback();
    return this;
  }
  this._events.once('ready', callback);
  return this;
};

module.exports = DiamondClient;
